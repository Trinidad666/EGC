# Intoducci√≥n

<details>
  <summary>üöÄ Explicaci√≥n de EGC</summary>
Nuestra empresa, EGC (Enterprise Global Chat), ofrece un servicio de chat especializado en diversos sectores como inform√°tica, negocios, econom√≠a, entre otros. Los usuarios registrados pueden consultar sus dudas directamente con expertos. Nuestro objetivo es brindar soluciones r√°pidas y efectivas, tanto para usuarios individuales como para peque√±as empresas.
<br>
<br>
  
Nuestra plataforma compite con otras herramientas de mensajer√≠a, como Telegram, Skype, Discord, y m√°s, especialmente en lo que respecta a la creaci√≥n de grupos y redes de usuarios. Sin embargo, en nuestra plataforma, todos los chats son privados entre los usuarios conectados, permitiendo conversaciones directas y seguras.
<br>

Al registrarse en nuestra web, los usuarios podr√°n acceder a grupos creados por especialistas en sectores como inform√°tica, negocios, econom√≠a y otros, disponibles en modalidades p√∫blicas o privadas. Adem√°s, los usuarios podr√°n crear sus propios grupos de conversaci√≥n para compartir informaci√≥n y resolver dudas con otros usuarios.
  
</details>
<br>



<details>
<summary>üé® Dise√±o de nuestra aplicaci√≥n</summary>


## Mockup

<details>
<summary>----------------->Dise√±o que queriamos implementar</summary>

### Home

* En la p√°gina de inicio tendr√≠amos una imagen de fondo, y en la parte superior de la pesta√±a se mostrar√≠a el logo junto a tres enlaces que dirigir√≠an a p√°ginas donde hablar√≠amos sobre nosotros, nuestra seguridad y soporte t√©cnico, as√≠ como al inicio de sesi√≥n. Adem√°s, contar√≠amos con un footer que incluir√≠a los logotipos de nuestras redes sociales.

![image](https://github.com/user-attachments/assets/7c5c27db-fa5a-4ce7-b655-c1a179c5a935)


### Sobre Nosotros

* En la secci√≥n "Sobre nosotros", os explicaremos qu√© hace nuestra empresa, cu√°ndo fue creada y qu√© ventajas ofrece en comparaci√≥n con otros servicios de chat. Tambi√©n incluir√≠amos im√°genes decorativas para mejorar la presentaci√≥n.

![image](https://github.com/user-attachments/assets/4367be43-9c0b-4f62-b6b4-724a5508d5c5)


### Nuestra Seguridad

* En la secci√≥n "Nuestra seguridad" explicaremos las medidas de seguridad que ofrecemos, sin entrar en detalles espec√≠ficos.

![image](https://github.com/user-attachments/assets/941276f0-4848-47e5-897f-c80d1c07cc01)


### Soporte T√©cnico

* En la secci√≥n de soporte t√©cnico, los usuarios podr√≠an ingresar su correo electr√≥nico, describir el problema que tienen y hacer clic en un bot√≥n de "Enviar".

![image](https://github.com/user-attachments/assets/63f4c1c3-9c71-42d7-8b81-6e513d4a79f4)


### Chat

* Este ser√≠a nuestro chat, con una lista a la izquierda que muestra nuestros contactos y amigos, y un buscador para encontrar a otros contactos.

![image](https://github.com/user-attachments/assets/6d88b906-7cba-4fa5-85a2-c13a1306e03a)


### Grupos

* En el cat√°logo, el usuario podr√° buscar temarios sobre ciberseguridad utilizando el buscador, y se le mostrar√°n diferentes temarios relacionados con el tema.

![image](https://github.com/user-attachments/assets/e68bcc31-368f-4f8c-a04e-0e3e9245ff63)


### Crear Grupo

* En "Crear cat√°logo", el usuario podr√° subir una imagen, a√±adir un t√≠tulo y un texto, y deber√° ingresar su nombre de usuario en un apartado. Al final, tendr√° un bot√≥n para crear el cat√°logo.

![image](https://github.com/user-attachments/assets/12724ed0-f878-4d0b-bd73-a0c204ee2e36)

### Registro

* As√≠ es como se ver√≠a la secci√≥n donde se registrar√≠an nuestros usuarios. En el formulario de registro, el usuario deber√° ingresar su nombre, primer apellido, un nombre de usuario, su correo electr√≥nico, n√∫mero de tel√©fono y una contrase√±a, la cual deber√° confirmar nuevamente.

![image](https://github.com/user-attachments/assets/587a3bd2-9e8c-4737-8d00-9a2e71e7e9d7)


### Inicio Sesi√≥n

* As√≠ es como se ver√≠a nuestro inicio de sesi√≥n. El usuario solo deber√° ingresar su correo electr√≥nico y contrase√±a.

![image](https://github.com/user-attachments/assets/37ec7c4c-e221-415c-9b8d-cca2adff63e8)

</details>

<br>
<br>

<details>
  <sumary>----------------->Dise√±o de la web que hemos implementado</sumary>
  ### Registro
* As√≠ es como se ver√≠a la secci√≥n donde se registrar√≠an nuestros usuarios. En el formulario de registro, el usuario deber√° ingresar nombre de usuario y una contrase√±a.

![image](https://github.com/user-attachments/assets/37bc91ac-d20b-4de7-9a5a-7fbd4e7e4d98)


### Inicio Sesi√≥n
* As√≠ es como se ver√≠a nuestro inicio de sesi√≥n. El usuario solo deber√° ingresar su correo electr√≥nico y contrase√±a.

![image](https://github.com/user-attachments/assets/b765d3db-171e-4802-86c1-1a858ad72e24)


### Chat
* As√≠ es como se ver√≠a nuestro chat. Una vez que el usuario se ha registrado se encuentra en una pantalla donde puede enviar y recibir mensajes. Tambi√©n contamos con dos botones que permiten hacer llamadas y colgarlas.

* En la zona izquierda, se encuentra la secci√≥n de Contactos, donde puedes crear un nuevo chat y buscar a un amigo mediante un buscador. M√°s abajo, encontrar√°s una lista de tus amigos, donde se indica si est√°n activos o no con un punto verde. Adem√°s, se ofrece la opci√≥n de eliminarlos.

* En la zona derecha, est√° la secci√≥n de Grupos, donde puedes crear un nuevo grupo. Tambi√©n hay un buscador para encontrar los grupos que has creado o en los que te has unido. M√°s abajo, aparece una lista de los grupos a los que perteneces, con la opci√≥n de salir y la cantidad de miembros del grupo.

![image](https://github.com/user-attachments/assets/d3bdf5f8-2e22-4e1a-8b0d-ed8c9c9b298d)


### Creaci√≥n de Grupos
* As√≠ es como se ver√≠a la creaci√≥n de grupos. Al crear un grupo, se nos presentan varias secciones donde debemos ingresar el nombre del grupo, una descripci√≥n, el tipo de grupo (p√∫blico o privado) y etiquetas. Las etiquetas sirven para indicar la tem√°tica del grupo, como m√∫sica, juegos, estudio, etc.

![image](https://github.com/user-attachments/assets/7441775d-9835-454c-b09c-de08dfa15d1a)


</details>


<br>


## Gamma de colores + Logo

### Nuestra gamma de colores

![image](https://github.com/user-attachments/assets/c999e1eb-701f-43bd-8a99-e5fd0f23e867)

### Nuestro Logo

![ECS](https://github.com/user-attachments/assets/6ba6de8e-952c-4265-9db4-ab254b4884f4)![image](https://github.com/user-attachments/assets/03bae469-1db6-44f0-bc5f-c439e731b600)


</details>
<br>










<details>
<summary>üó∫Ô∏è Nuestros esquemas</summary>
Este es nuestro esquema de nuestra web EGC:

![image](https://github.com/user-attachments/assets/d29a31b2-477b-47cb-b0c9-4ed494235236)


</details>
<br>


<details>
<summary>üìä Nuestros Diagramas</summary>

## Diagrama de RED
Como podemos ver en nuestro esquema de red, las m√°quinas de nuestro Proxmox se conectan al switch (vmbr0), que a su vez se conecta al router de IFP, proporcion√°ndonos la conexi√≥n a Internet. Ahora, os mostraremos las m√°quinas virtuales que contiene nuestro **Proxmox**:

1. Contamos con una m√°quina virtual (MV) que act√∫a como router y se conecta a trav√©s de **pfSense**, que funciona como el firewall de nuestro proyecto.
2. Tenemos una con el **DNS**.
3. Tenemos una MV donde almacenaremos la **WEB** y el **NGINX**.
4. Una con la bas de datos de **MongoDB**.
5. Contamos con una a la que hemos llamado **cliente** que utilizamos como prueba para verificar si nuestra web funciona correctamente.
6. Otra que contiene nuestro **Docker**.
7. Nuestro **servidor de correo**.
8. Contamos con una MV donde se almacenar√°n nuestros **backups** de **copias de seguridad** y **recuperaci√≥n**.

![Esquema-Red-Visual-Paradigm](https://github.com/user-attachments/assets/0e365779-b6c6-4654-9f4b-aa757ba3182c)


## Diagrama de BBDD
Como podemos ver en nuestro diagrama, la tabla **users** se conecta a la tabla **channels** utilizando las tablas de relaci√≥n **file** y **messages**. Tambi√©n, la tabla usuarios tiene, en conexi√≥n aparte, la tabla **friends** y la de **private_chat**.
Tambi√©n tenemos dos tablas de bloqueos, unas es para **Friends** y otra la usariamos en **Channels**.

Como podemos ver en nuestro diagrama, la tabla **users** se conecta a la tabla channels mediante las tablas de relaci√≥n **file** y **messages**. Adem√°s, la tabla users tiene, en una conexi√≥n aparte, la tabla **friends** y la de **private_chat**. Tambi√©n contamos con dos tablas de bloqueos: una es **block_friends**, que se utiliza para bloquear a amigos, y la otra es **block_channels**, que se usa para bloquear canales.


![image](https://github.com/user-attachments/assets/3c5e8c62-6a0e-470c-ba1f-e95a000f59e4)





</details>
<br>





<details>
<summary>üêã Docker</summary>

# ¬øQue es el Docker?

Docker es una plataforma que permite crear, distribuir y ejecutar aplicaciones en contenedores. Un contenedor es un entorno ligero y port√°til que incluye todo lo necesario para ejecutar un software, como c√≥digo, bibliotecas y dependencias, asegurando que funcione igual en cualquier sistema. Docker facilita la gesti√≥n y escalabilidad de aplicaciones, optimizando el uso de recursos y mejorando la eficiencia en desarrollo y despliegue. Se basa en im√°genes preconfiguradas y permite automatizar procesos, haci√©ndolo ideal para entornos de desarrollo, pruebas y producci√≥n en la nube o servidores locales.

![image](https://github.com/user-attachments/assets/538841f9-274d-48d4-9fd9-04ec71d46ebc)




# ¬øQu√© ventajas y desventajas ofrece Docker?


## Ventajas‚úÖ

¬∑ **Portabilidad de contenedores**: Los contenedores funcionan igual en cualquier sistema con Docker instalado.

¬∑ **Eficiencia**: Consume menos recursos que las m√°quinas virtuales porque comparte el sistema operativo.

¬∑ **Escalabilidad**: Facilita la gesti√≥n y despliegue de m√∫ltiples instancias de aplicaciones.

¬∑ **R√°pido despliegue**: Permite automatizar e implementar aplicaciones en segundos.

¬∑ **Aislamiento**: Evita conflictos entre dependencias de diferentes aplicaciones.



## Desventajas‚ùå

¬∑ **Rendimiento**: Puede ser menos eficiente que una ejecuci√≥n nativa.

¬∑ **Persistencia de datos**: Manejo de almacenamiento m√°s complejo.

¬∑ **Seguridad**: Comparte el kernel del host, lo que puede generar vulnerabilidades.



  
# Introducci√≥n a la instalaci√≥n de la web

Guardamos el contenido de la p√°gina web en una carpeta llamada web y la comprimimos en un archivo zip. Luego, la exportaremos a la m√°quina Alpine desde cmd utilizando el siguiente comando:

![image](https://github.com/user-attachments/assets/12bb95df-3edd-4466-9dd6-deb9006288c3)


Para descomprimir la carpeta que hemos exportado, utilizaremos el comando unzip. Luego, creamos una carpeta llamada **rbooks** donde almacenaremos la carpeta web que hemos descomprimido. Ser√° necesario mover la carpeta web dentro de la carpeta **rbooks**.


Accedemos a la carpeta **rbooks** y creamos las siguientes subcarpetas que mostraremos a continuaci√≥n:

![image](https://github.com/user-attachments/assets/8321eee2-4f73-4e67-9cb4-78866dbcaa43)


Dentro de la carpeta **nginx**, creamos un archivo llamado **default.conf** y le a√±adimos el siguiente c√≥digo:

![image](https://github.com/user-attachments/assets/90ee82b1-20dc-441f-b3be-433fbe1ac5a4)


Una vez hecho esto, salimos de la carpeta **nginx** y, dentro de **rbooks**, creamos un nuevo archivo llamado **docker-compose.yml**. A continuaci√≥n, en el archivo **docker-compose.yml**, aseguramos que el servicio **phpfpm** utilice el *Dockerfile* para construir la imagen personalizada. En lugar de usar la imagen **php:8-fpm-alpine** directamente, debemos indicar que se debe construir la imagen utilizando el *Dockerfile*.

```
services:
  # PHP service
  phpfpm:
    build:
      context: .
      dockerfile: Dockerfile   # Usa el Dockerfile personalizado
    container_name: phpfpm
    working_dir: /var/www/rbooks
    ports:
      - "9000:9000"
    volumes:
      - './web:/var/www/rbooks'
    environment:
      PHP_INI_DIR: /usr/local/etc/php
    restart: always
    networks:
      - netweb

  # Nginx service
  nginx:
    image: nginx:alpine
    container_name: nginx
    ports:
      - "8082:80"
    working_dir: /etc/nginx
    volumes:
      - './web:/var/www/rbooks'
      - './nginx/default.conf:/etc/nginx/conf.d/default.conf'
      - './nginx/:/var/log/nginx/'
    restart: always
    networks:
      - netweb

  # MySQL database service
  db:
    image: mysql
    container_name: miDB
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: 1234
    volumes:
      - './mysql:/var/lib/mysql'
      - './sql:/db'
    networks:
      - netweb

  # PHPMYADMIN
  phpmyadmin:
    image: phpmyadmin
    container_name: miphpmyadmin
    environment:
      PMA_ARBITRARY: 1
      PMA_HOST: db  # Conectar phpMyAdmin al contenedor "db" (MySQL)
    ports:
      - "81:80"
    networks:
      - netweb

networks:
  netweb:
    driver: bridge

```


A continuaci√≥n, crearemos el archivo **Dockerfile** y a√±adiremos el siguiente c√≥digo para que funcione:

![image](https://github.com/user-attachments/assets/fdf3e8b4-c8e5-4f59-8688-1e79b32abbb1)


Este comando permite forzar la recreaci√≥n de los contenedores en el **docker**.

![image](https://github.com/user-attachments/assets/152d72fb-a268-4556-888d-92b322e7e909)


Si accedemos a **Portainer** y vamos a la secci√≥n de **Contenedores**, podemos ver que se ha creado de forma correcta.

![image](https://github.com/user-attachments/assets/8b4ad89a-204d-4f24-87a1-d69f03bb1b1a)








Si accedemos al navegador y ponemos **http://100.77.20.22:8082**, podremos ver que hemos ingresado correctamente a la p√°gina web de RBooks.

![image](https://github.com/user-attachments/assets/574a6d8b-f4c5-4d1b-94d8-e1fc120731d3)


Ahora, debemos cargar la base de datos en **phpMyAdmin** para que las tablas se muestren correctamente y los registros funcionen en la p√°gina web. Para ello, accedemos a **http://100.77.20.22:81** en el navegador.
* Servidor --> miDB
* Usuario --> root
* Contrase√±a --> 1234
 
![image](https://github.com/user-attachments/assets/c53a9069-f0ab-4231-a811-68cecc4c103c)


Creamos la base de datos con el nombre **rbooks**.

![image](https://github.com/user-attachments/assets/04b92b6c-414e-4112-bf8d-d7967d416278)


Para poder importar el archivo **sql** en **phpMyAdmin**, debemos ingresar en la base de datos **rbooks**, hacer clic en *Importar*, seleccionar el archivo **bbdd-rbooks.sql** y luego hacer clic en el bot√≥n *Importar*.

![image](https://github.com/user-attachments/assets/2c2f841b-84cb-4e38-a4b2-d93207c67853)


A continuaci√≥n, accedemos al archivo **conexion_be.php**, que se encuentra en la ruta ***web/php_in-sing/conexion_be.php***, y modificamos la direcci√≥n de la base de datos para establecer la conexi√≥n entre la p√°gina web y la base de datos.

![image](https://github.com/user-attachments/assets/89863329-095d-4ba2-a6ff-69adf2947224)

<br>
<br>
<br>

# Las mejoras que hemos a√±adido

Estos son los comandos que le hemos puesto en el archivo **docker-compose.yml**.

<br>
<br>

## context: .

‚Ä¢	Define el directorio base donde Docker buscar√° los archivos necesarios para construir la imagen.

‚Ä¢	En este caso, el **.** (punto) indica que el contexto de construcci√≥n es el directorio donde se encuentra el archivo docker-compose.yml.


## dockerfile: Dockerfile

‚Ä¢	Indica al Docker qu√© archivo usar para construir la imagen. En este caso, se usar√° el Dockerfile que est√° en el contexto definido arriba (.).

‚Ä¢	Permite personalizar la imagen en lugar de usar una predefinida.



## PHP_INI_DIR: /usr/local/etc/php

Define la variable de entorno PHP_INI_DIR, que indica la ubicaci√≥n del archivo de configuraci√≥n de PHP (php.ini) dentro del contenedor.

<br>
<br>

## Dockerfile Vs docker-compose
![image](https://github.com/user-attachments/assets/7dbc6d20-f0fb-4d98-9a43-3b748478d106)



## Dockerfile

### 1Ô∏è‚É£ FROM php:8-fpm-alpine

```
FROM php:8-fpm-alpine
```

Define la imagen base como php:8-fpm-alpine.



### 2Ô∏è‚É£ Instalaci√≥n de dependencias y extensiones

```
RUN apk add --no-cache libpng-dev libjpeg-turbo-dev libwebp-dev \
    && docker-php-ext-install mysqli pdo pdo_mysql
```

Usa apk add --no-cache para instalar dependencias en Alpine Linux:

‚Ä¢	libpng-dev, libjpeg-turbo-dev, libwebp-dev: Bibliotecas necesarias para manipulaci√≥n de im√°genes en PHP.


Luego, instala extensiones de PHP con docker-php-ext-install:

‚Ä¢	mysqli: Extensi√≥n para conectarse a bases de datos MySQL.

‚Ä¢	pdo y pdo_mysql: Permiten usar PDO (PHP Data Objects) con MySQL.




### 3Ô∏è‚É£ (Opcional) Ajustar php.ini para habilitar mysqli

```
# RUN echo "extension=mysqli.so" >> /usr/local/etc/php/conf.d/docker-php-ext-mysqli.ini
```

Agrega manualmente la l√≠nea **extension=mysqli.so** al archivo de configuraci√≥n de PHP. Se usar√° cuando PHP no detecta autom√°ticamente la extensi√≥n mysqli.


üîπ ¬øCu√°ndo usarlo?

Si mysqli no se activa correctamente despu√©s de instalarlo con docker-php-ext-install para asegurar de que PHP cargue la extensi√≥n en cada inicio.







</details>
<br>








<details>
<summary>‚öôÔ∏è Funcionalidades</summary>
Funcionalidades que vamos a implementar:

- Funcionalidades de Registro e inicio de sesi√≥n.(V√≠ctor)
- Que los usuarios puedan tener contactos o conversaci√≥n con t√©cnicos inform√°ticos.(Hugo)
- Los usuarios pueden crear una tabla de t√©cnicos inform√°ticos. (V√≠ctor)


Seguridad (en funci√≥n de vuestro proyecto):

- MongoDB
- Protecci√≥n de c√≥digo fuente
- toda la parte de monitorizaci√≥n y seguridad que vais a implementar
</details>
<br>



<details>
<summary>üñ•Ô∏è Arquitectura del Sistema</summary>
Estos seran los componentes de tecnolog√≠a que utilizaremos en el sistema:

- **NGINX:** Servidor web y proxy inverso que gestiona eficazmente el tr√°fico y balancea la carga de las aplicaciones.

- **MongoDB:** Base de datos NoSQL que almacena documentos en lugar de tablas, ideal para manejar grandes vol√∫menes de datos no estructurados.

- **PHP:** Lenguaje de programaci√≥n del lado del servidor, usado para generar contenido din√°mico en p√°ginas web.

- **HTML:** Lenguaje para estructurar y organizar el contenido de una p√°gina web.

- **CSS:** Lenguaje para aplicar estilos y dise√±os visuales a las p√°ginas web.

- **JS:** Lenguaje para agregar interactividad y funcionalidades en el navegador.

- **Bind9:** Servidor DNS que traduce nombres de dominio a direcciones IP.

- **Docker:** Plataforma que facilita la creaci√≥n y gesti√≥n de contenedores para ejecutar aplicaciones de manera aislada.

- **Composer:** Herramienta para gestionar las dependencias y bibliotecas en proyectos PHP.

- **WebSocket:** Protocolo para comunicaci√≥n bidireccional en tiempo real entre cliente y servidor.

- **WebRTC:** Es para hacer llamadas en tiempo real sin necesidad de tener un n√∫mero de tel√©fono.

- **IPTables:** Herramienta en Linux para configurar un firewall y controlar el tr√°fico de red.



</details>
<br>


<details>
<summary>üì¶‚òÅÔ∏èMaquinas Virtuales</summary>

<br>


<details>
<summary>+----------üåêüîÑüñ•Ô∏è DNS</summary>

  
</details>
<br>


<details>
<summary>+----------üåêüñ•Ô∏è WEB/NGINX</summary>

  
</details>
<br>


<details>
<summary>+----------üçÉüóÉÔ∏è MongoDB</summary>

  
</details>
<br>


<details>
<summary>+----------üë§ Cliente</summary>

  
</details>
<br>


<details>
<summary>+----------üê≥ Docker</summary>

  
</details>
<br>


<details>
<summary>+----------üìß Server Email</summary>

  
</details>
<br>


<details>
<summary>+----------üíæüîí Backup/Recuperaci√≥n</summary>

  
</details>
<br>



<details>
<summary>+----------üêß Sistemas Operativos</summary>

Estos son los Sistemas Operativos que vamos a implementar en la Maquina virtuales.


- Ubuntu Server
  
- Alpine (Docker)

- Firewall


  
</details>
<br>




<details>
<summary>+----------üî≤ Hardware</summary>

Todas las VM tienen la misma capacidad de memoria RAM, CPU y disco duro, menos la VM Docker.

MV:
- RAM --> 2 GB
- CPU --> 1 (1 socket & 1 cores)
- HD --> 14 GB
<br>

MV Docker:
- RAM --> 4 GB
- CPU --> 4 (2 sockets & 2 cores)
- HD --> 60 GB

  
</details>

</details>
  
<br>

<details>
<summary>üõ°Ô∏èSeguridad</summary>

<br>

<details>
<summary>+----------üí† Tipos de Seguridad</summary>

# üî• Protecci√≥n contra ataques (DDoS, Hydra, etc.)

<br>

## 1Ô∏è‚É£ En el Router/Ubuntu (Entrada de la red)

üìå Motivo: Es el primer punto de entrada y debe filtrar tr√°fico malicioso antes de que llegue a los servidores internos.

‚úÖ Medidas:

* Firewall (iptables, UFW): Restringir accesos por IP y puertos.

* Sistema de Prevenci√≥n de Intrusos (IPS) como Fail2Ban o Suricata: Detectar y bloquear intentos de fuerza bruta (Hydra).

* Protecci√≥n contra DDoS (Cloudflare, iptables con rate limiting, servicios de mitigaci√≥n DDoS como AWS Shield o Cloudflare).

* VPN (WireGuard, OpenVPN): Para acceso seguro de administradores.

<br>

## 2Ô∏è‚É£ Servidor Web

üìå Motivo: Objetivo principal de ataques como DDoS, SQL Injection y explotaci√≥n de vulnerabilidades.

‚úÖ Medidas:

* WAF (Web Application Firewall) como ModSecurity: Bloqueo de ataques a la aplicaci√≥n web.

* Limitaci√≥n de conexiones simult√°neas con herramientas como fail2ban.

* TLS/SSL para cifrar la comunicaci√≥n HTTPS.

<br>

## 3Ô∏è‚É£ Servidor Base de Datos

üìå Motivo: Contiene informaci√≥n sensible y puede sufrir SQL Injection o ataques de fuerza bruta.

‚úÖ Medidas:

* Permitir conexiones solo desde el servidor web (bloquear accesos externos).

* Cifrar datos sensibles en la base de datos.

* Autenticaci√≥n fuerte y rotaci√≥n de contrase√±as.

<br>

## 4Ô∏è‚É£ Docker

üìå Motivo: Puede contener aplicaciones con vulnerabilidades explotables.

‚úÖ Medidas:

* Restringir acceso a contenedores con redes privadas.

* Escanear im√°genes con herramientas como Trivy.

* Configurar permisos m√≠nimos en los contenedores.

<br>

## 5Ô∏è‚É£ Servidor de Correo

üìå Motivo: Sujeto a ataques de phishing y fuerza bruta (SMTP, IMAP, POP3).

‚úÖ Medidas:

* SPF, DKIM y DMARC para evitar suplantaci√≥n de identidad.

* Rate limiting para prevenir ataques de fuerza bruta.

* Filtrado de spam con herramientas como SpamAssassin.

<br>

## 6Ô∏è‚É£ Servidor DNS

üìå Motivo: Puede ser objetivo de ataques de envenenamiento de cach√© o DDoS.

‚úÖ Medidas:

* DNSSEC para validar respuestas DNS.

* Rate limiting en consultas para mit

<br>

</details>




<br>

<details>
<summary>+----------üìÑüõ°Ô∏è Backup (Copias de Segiridad)</summary>

**https://www.incibe.es/sites/default/files/contenidos/guias/guia-copias-de-seguridad.pdf**
  
# ¬øQu√© es una copia de seguridad y que importancia tiene?

Una copia de seguridad es un proceso que permite duplicar y almacenar informaci√≥n con el fin de recuperarla en caso de p√©rdida o fallo del sistema. En el √°mbito empresarial, resulta fundamental para garantizar la continuidad del negocio y mantener la confianza de los clientes. Forma parte de los planes de seguridad y contingencia, asegurando la protecci√≥n, disponibilidad y recuperaci√≥n de los datos de manera eficiente y peri√≥dica.

Imagina que tienes un cuaderno en el que anotas informaci√≥n crucial para tu escuela. Si lo pierdes o se da√±a, toda esa informaci√≥n desaparecer√≠a, lo que ser√≠a un gran problema. Lo mismo ocurre con los datos de un negocio: si no se cuenta con una copia de seguridad, cualquier fallo, error humano o ciberataque podr√≠a ocasionar la p√©rdida definitiva de informaci√≥n valiosa.
Por ello, realizar copias de seguridad regularmente es esencial. Es como tener una segunda versi√≥n de tu cuaderno guardada en un lugar seguro, lista para ser utilizada en caso de emergencia, evitando as√≠ p√©rdidas irreparables y garantizando la estabilidad de la informaci√≥n.


# ¬øQu√© copias de seguridad hariamosa?
Para definir qu√© informaci√≥n debe incluirse en las copias de seguridad, primero es necesario realizar un inventario de activos y clasificar los datos seg√∫n su importancia para el negocio. Esta clasificaci√≥n nos permitir√° priorizar la protecci√≥n de la informaci√≥n cr√≠tica y definir estrategias adecuadas de respaldo:

* Confidencialidad: (confidencial, interna, p√∫blica).

* Utilidad: (clientes, ventas, personal).

* Impacto: (da√±o de imagen, consecuencias legales, econ√≥micas, paralizaci√≥n de la actividad).

Esto ayuda a establecer medidas de seguridad y decidir qu√© informaci√≥n proteger, como datos de clientes, ventas o personal, y su frecuencia de respaldo.


# ¬øQu√© estrategias seguir√≠amos?
Para garantizar la seguridad y disponibilidad de nuestros datos, aplicaremos la estrategia 3-2-1 de copias de seguridad, una de las mejores pr√°cticas en la gesti√≥n de respaldos. Su objetivo es diversificar el almacenamiento de las copias para minimizar el riesgo de p√©rdida de informaci√≥n y asegurar la posibilidad de recuperaci√≥n en caso de fallo. Sus principios clave son:

* 3 copias: Mantener tres versiones de cada archivo importante: el original y al menos dos copias de respaldo.
* 2 soportes diferentes: Almacenar las copias en al menos dos tipos de medios distintos (por ejemplo, un disco duro externo y almacenamiento en la nube) para mitigar riesgos como fallos mec√°nicos o corrupci√≥n de datos.
* 1 copia fuera de la empresa: Guardar al menos una copia en una ubicaci√≥n externa (como un servicio de almacenamiento en la nube) para proteger la informaci√≥n ante desastres f√≠sicos, robos o ciberataques en la infraestructura local.

Ejemplo pr√°ctico
Si trabajamos con un archivo cr√≠tico llamado "listadoproveedores.ots", podr√≠amos aplicar la estrategia 3-2-1 de la siguiente manera:

* Archivo original: Se almacena en el equipo principal donde se trabaja con √©l.
* Primera copia de seguridad: Se guarda en un disco duro externo o servidor NAS local.
* Segunda copia de seguridad: Se sube a un servicio de almacenamiento en la nube (cumpliendo tambi√©n con la regla de "ubicaci√≥n externa").


# ¬øD√≥nde se van a ubicar las copias?

Por el momento, almacenaremos nuestras copias de seguridad en Google Drive y en discos duros externos como medida preventiva ante cualquier incidente inesperado, garantizando que siempre tengamos acceso a nuestros datos en caso de fallos o imprevistos.

Adem√°s, hemos decidido implementar un sistema de almacenamiento en la nube para reforzar a√∫n m√°s la seguridad y disponibilidad de la informaci√≥n. Actualmente, estamos en proceso de evaluaci√≥n y configuraci√≥n de este servicio, asegur√°ndonos de elegir la mejor opci√≥n en t√©rminos de fiabilidad, cifrado y accesibilidad.

Tambi√©n crearemos una m√°quina virtual en Proxmox que funcionar√° como servidor central para almacenar toda la informaci√≥n, bases de datos y c√≥digo fuente de nuestro proyecto. Adem√°s, configuraremos copias de seguridad automatizadas y medidas de seguridad como firewalls y cifrado para garantizar la integridad y protecci√≥n de los datos.


# Esto sera la informaci√≥n que copiaremos para asegurar nuestro proyecto:

* Base de Datos: La informaci√≥n de los usuarios y datos cr√≠ticos de la empresa deben resguardarse con la mayor frecuencia posible. Un respaldo frecuente y seguro es clave para evitar p√©rdidas de informaci√≥n valiosa.

* DNS: El DNS es fundamental para el funcionamiento de los servicios en l√≠nea, asegurando que los dominios est√©n correctamente direccionados. Un backup del DNS garantiza que la infraestructura web siga operativa en caso de fallos.

* C√≥digo de la Web y Nginx: Resguardar el c√≥digo fuente de la web junto con la configuraci√≥n de Nginx es esencial para una r√°pida recuperaci√≥n en caso de incidentes o ataques.

* Router: Mantener una copia de seguridad de la configuraci√≥n del router es crucial para garantizar la conectividad de la red y facilitar su restauraci√≥n en caso de fallas o modificaciones accidentales.



# C√≥digos del Backup
## Copias de seguridad
Hemos creado este script en Bash para automatizar la copia de seguridad cifrada de archivos desde servidores remotos a un sistema local. Su objetivo es garantizar que los respaldos sean descargados, cifrados y almacenados de forma segura, manteniendo un historial controlado mediante la gesti√≥n de copias previas y registros en un archivo de log. A continuaci√≥n, os mostraremos que hace cada parte del c√≥digo:

1. Configuraci√≥n de usuarios de los ordenadores de destino, IPs de los ordenadores, carpeta local de respaldo, rutas en los ordenadores remotos, carpeta de logs, formato de fecha y hora; y archivo de log.
2. Crear la carpeta de logs si no existe.
3. Redirigir la salida est√°ndar y los errores al archivo de log.
4. Escribir en el log el inicio de la ejecuci√≥n.
5. Preguntar al usuario a qui√©n desea enviar los archivos.
6. Verificar si el usuario ingresado es v√°lido.
7. Obtener el √≠ndice del usuario seleccionado.
8. Verificar si el √≠ndice fue encontrado.
9. Obtener las configuraciones correspondientes para el usuario seleccionado.
10. Buscar los archivos de respaldo espec√≠ficos para el usuario seleccionado.
11. Verificar si se han encontrado archivos de respaldo.
12. Verificar si el destino est√° accesible.
13. Bucle para enviar los archivos de respaldo.

```
#!/bin/bash

# Configuraci√≥n
USUARIOS_ORIGEN=("hugo" "cliente")  # Lista de usuarios en diferentes ordenadores
IPS_ORIGEN=("192.168.6.10" "192.168.6.11")  # IPs de los ordenadores remotos
CARPETAS_ORIGEN=("/home/hugo/origen" "/home/cliente/origen")  # Rutas de las carpetas a copiar
CARPETA_DESTINO="/home/hugo/buckup-all/destino"  # Se guardar√° en el equipo local
CARPETA_TEMP="/tmp/backup_encrypt"
SCRIPT_DIR="$(dirname "$(realpath "$0")")"  # Obtiene la ruta del script
LOG_DIR="$SCRIPT_DIR/logs"
TIMESTAMP="$(date '+%H.%M_%d-%m-%Y')"  # Formato de fecha y hora
LOG_FILE="$LOG_DIR/backup_$TIMESTAMP.log"
CLAVE_CIFRADO="alumno"

# Crear carpeta de logs si no existe
mkdir -p "$LOG_DIR"

# Redirigir salida est√°ndar y errores al archivo de log
exec >> "$LOG_FILE" 2>&1

echo "[$(date)] - Iniciando respaldo remoto con cifrado..."

# Verificar que las listas de usuarios, IPs y carpetas tengan la misma cantidad de elementos
if [ ${#USUARIOS_ORIGEN[@]} -ne ${#IPS_ORIGEN[@]} ] || [ ${#USUARIOS_ORIGEN[@]} -ne ${#CARPETAS_ORIGEN[@]} ]; then
    echo "[$(date)] - Error: Las listas de usuarios, IPs y carpetas de origen deben tener la misma cantidad de elementos."
    exit 1
fi

# Bucle para procesar cada origen
for i in "${!USUARIOS_ORIGEN[@]}"; do
    USUARIO_ORIGEN="${USUARIOS_ORIGEN[$i]}"
    IP_ORIGEN="${IPS_ORIGEN[$i]}"
    CARPETA_ORIGEN="${CARPETAS_ORIGEN[$i]}"

    echo "[$(date)] - Conectando a $USUARIO_ORIGEN@$IP_ORIGEN..."
    
    # Verificar conexi√≥n SSH con el equipo remoto
    if ! nc -z "$IP_ORIGEN" 22; then
        echo "[$(date)] - Error: No se puede conectar a $IP_ORIGEN en el puerto 22."
        continue  # Continuar con el siguiente origen si no se puede conectar
    fi

    # Crear carpeta temporal para los archivos cifrados
    mkdir -p "$CARPETA_TEMP"

    # Copiar archivos desde el equipo remoto
    echo "[$(date)] - Descargando archivos desde el servidor remoto $IP_ORIGEN..."
    if rsync -avz -e "ssh -p 22" "$USUARIO_ORIGEN@$IP_ORIGEN:$CARPETA_ORIGEN/" "$CARPETA_TEMP/"; then
        echo "[$(date)] - Archivos descargados con √©xito desde $IP_ORIGEN."
    else
        echo "[$(date)] - Error: Fallo en la sincronizaci√≥n con rsync desde $IP_ORIGEN."
        rm -rf "$CARPETA_TEMP"
        continue  # Continuar con el siguiente origen si rsync falla
    fi

    # Crear carpeta espec√≠fica para el usuario en el destino
    USUARIO_DESTINO="$CARPETA_DESTINO/$USUARIO_ORIGEN"
    mkdir -p "$USUARIO_DESTINO"

    # Gestionar el n√∫mero m√°ximo de copias (3)
    echo "[$(date)] - Verificando copias anteriores en $USUARIO_DESTINO..."
    ARCHIVOS_ANTIGUOS=($(ls -t $USUARIO_DESTINO/backup_${USUARIO_ORIGEN}_*.tar.gz.gpg))
    NUM_COPIAS=${#ARCHIVOS_ANTIGUOS[@]}
    
    if [ $NUM_COPIAS -ge 3 ]; then
        # Eliminar las copias m√°s antiguas (mantener solo las 2 m√°s recientes)
        ARCHIVOS_A_ELIMINAR=("${ARCHIVOS_ANTIGUOS[@]:2}")
        echo "[$(date)] - Eliminando copias antiguas: ${ARCHIVOS_A_ELIMINAR[@]}"
        rm -f "${ARCHIVOS_A_ELIMINAR[@]}"
    fi

    # Cifrar archivos manteniendo la estructura original
    echo "[$(date)] - Cifrando archivos descargados desde $IP_ORIGEN..."
    tar -czf - -C "$CARPETA_TEMP" . | \
    gpg --symmetric --cipher-algo AES256 --passphrase "$CLAVE_CIFRADO" --batch -o "$USUARIO_DESTINO/backup_${USUARIO_ORIGEN}_${TIMESTAMP}.tar.gz.gpg"

    if [ $? -eq 0 ]; then
        echo "[$(date)] - Respaldo cifrado de $USUARIO_ORIGEN almacenado en: $USUARIO_DESTINO/backup_${USUARIO_ORIGEN}_${TIMESTAMP}.tar.gz.gpg"
    else
        echo "[$(date)] - Error en el cifrado del respaldo desde $IP_ORIGEN."
    fi

    # Limpiar archivos temporales
    rm -rf "$CARPETA_TEMP"

done

# Instrucciones para descifrar
echo "[$(date)] - Para descifrar en este equipo, ejecutar:"
echo "  gpg --decrypt --passphrase \"$CLAVE_CIFRADO\" --batch $CARPETA_DESTINO/<usuario>/backup_<usuario>_<timestamp>.tar.gz.gpg | tar -xz -C $CARPETA_DESTINO/<usuario>"

echo "[$(date)] - Respaldo finalizado."
```

<br>


## Recuperaci√≥n de las copias de seguridad
Hemos creado este script para transferir copias de seguridad cifradas (.tar.gz.gpg) desde una m√°quina local a un servidor remoto, asegurando que los respaldos sean enviados de manera segura y organizada. Su prop√≥sito es automatizar la transferencia de respaldos mientras se registran los eventos en un archivo de log para garantizar trazabilidad. A continuaci√≥n, se describe brevemente c√≥mo funciona.

1. Tenemos la configuraci√≥n de los usuarios en los ordenes de destino, IPs, carpeta local donde esta respaldado, rutas en los ordenadores remotos, carpetas log, formato de la fecha y hora; y el archivo log.
2. Crear la carpeta de logs si no existe.
3. Redirigir la salida est√°ndar y los errores al archivo de log.
4. Escribir en el log el inicio de la ejecuci√≥n.
5. Preguntar al usuario a qui√©n desea enviar los archivos.
6. Verificar si el usuario ingresado es v√°lido.
7. Obtener el √≠ndice del usuario seleccionado.
8. Verificar si el √≠ndice fue encontrado.
9. Obtener las configuraciones correspondientes para el usuario seleccionado.
10. Buscar los archivos de respaldo espec√≠ficos para el usuario seleccionado.
11. Verificar si se han encontrado archivos de respaldo.
12. Verificar si el destino est√° accesible.
13. Bucle para enviar los archivos de respaldo.

```
#!/bin/bash

# Configuraci√≥n
USUARIOS_DESTINO=("hugo" "cliente")  # Usuarios en los ordenadores de destino
IPS_DESTINO=("192.168.6.10" "192.168.6.11")  # IPs de los ordenadores de destino
CARPETA_DESTINO_LOCAL="/home/hugo/buckup-all/destino"  # Carpeta local donde est√°n los respaldos
CARPETA_DESTINO_REMOTO=("/home/hugo/recuperacion" "/home/cliente/recuperacion")  # Rutas en los ordenadores remotos
LOG_DIR="/home/hugo/buckup-all/logs-recup"  # Carpeta de logs
TIMESTAMP="$(date '+%H.%M_%d-%m-%Y')"  # Formato de fecha y hora
LOG_FILE="$LOG_DIR/transferencia_$TIMESTAMP.log"  # Archivo de log

# Crear la carpeta de logs si no existe
mkdir -p "$LOG_DIR"

# Redirigir la salida est√°ndar y los errores al archivo de log
exec >> "$LOG_FILE" 2>&1

# Escribir en el log el inicio de la ejecuci√≥n
echo "[$(date)] - Iniciando transferencia de respaldos."

# Preguntar al usuario a qui√©n desea enviar los archivos
echo "[$(date)] - ¬øA qu√© ordenador deseas enviar los archivos? (hugo/cliente)"
read -p "Escribe 'hugo' o 'cliente': " USUARIO_SELECCIONADO

# Verificar si el usuario ingresado es v√°lido
if [[ ! " ${USUARIOS_DESTINO[@]} " =~ " ${USUARIO_SELECCIONADO} " ]]; then
    echo "[$(date)] - Error: Usuario '$USUARIO_SELECCIONADO' no v√°lido. Selecciona entre 'hugo' o 'cliente'."
    exit 1
fi

# Obtener el √≠ndice del usuario seleccionado
INDEX=-1
for i in "${!USUARIOS_DESTINO[@]}"; do
    if [ "${USUARIOS_DESTINO[$i]}" == "$USUARIO_SELECCIONADO" ]; then
        INDEX=$i
        break
    fi
done

# Verificar si el √≠ndice fue encontrado
if [ $INDEX -eq -1 ]; then
    echo "[$(date)] - Error: No se encontr√≥ el √≠ndice del usuario seleccionado."
    exit 1
fi

# Obtener las configuraciones correspondientes para el usuario seleccionado
USUARIO_DESTINO="${USUARIOS_DESTINO[$INDEX]}"
IP_DESTINO="${IPS_DESTINO[$INDEX]}"
CARPETA_DESTINO_USUARIO="${CARPETA_DESTINO_REMOTO[$INDEX]}"

# Buscar los archivos de respaldo espec√≠ficos para el usuario seleccionado
ARCHIVOS_ANTIGUOS=($(ls $CARPETA_DESTINO_LOCAL/$USUARIO_DESTINO/backup_*.tar.gz.gpg 2>/dev/null))

# Verificar si se han encontrado archivos de respaldo
if [ ${#ARCHIVOS_ANTIGUOS[@]} -eq 0 ]; then
    echo "[$(date)] - Error: No hay archivos de respaldo para enviar para el usuario $USUARIO_DESTINO en la carpeta $CARPETA_DESTINO_LOCAL/$USUARIO_DESTINO."
    exit 1
fi

# Verificar si el destino est√° accesible
echo "[$(date)] - Conectando a $USUARIO_DESTINO@$IP_DESTINO..."

if ! nc -z "$IP_DESTINO" 22; then
    echo "[$(date)] - Error: No se puede conectar a $IP_DESTINO en el puerto 22."
    exit 1
fi

# Bucle para enviar los archivos de respaldo
for archivo in "${ARCHIVOS_ANTIGUOS[@]}"; do
    echo "[$(date)] - Enviando archivo $archivo a $USUARIO_DESTINO@$IP_DESTINO:$CARPETA_DESTINO_USUARIO..."
    
    # Usar rsync para transferir el archivo de respaldo al destino remoto
    if rsync -avz -e "ssh -p 22" "$archivo" "$USUARIO_DESTINO@$IP_DESTINO:$CARPETA_DESTINO_USUARIO/"; then
        echo "[$(date)] - Archivo $archivo enviado exitosamente a $USUARIO_DESTINO@$IP_DESTINO."
    else
        echo "[$(date)] - Error al enviar el archivo $archivo a $USUARIO_DESTINO@$IP_DESTINO."
    fi
done

echo "[$(date)] - Transferencia de respaldos finalizada."

```
<br>


## Autenticaci√≥n SSH sin Contrase√±a para un Script

Para evitar que el script solicite una contrase√±a al ejecutar los comandos SSH y rsync, debes configurar la autenticaci√≥n sin contrase√±a mediante claves SSH.


### Generar una clave SSH en el cliente



```
ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N ""

```

Esto generar√° un par de claves:

* ~/.ssh/id_rsa (clave privada)
* ~/.ssh/id_rsa.pub (clave p√∫blica)



### Copiar la clave p√∫blica al servidor destino

Usa el siguiente comando para copiar autom√°ticamente la clave p√∫blica al servidor:

```
ssh-copy-id hugo@192.168.6.10

```

Si no tienes ssh-copy-id, puedes hacerlo manualmente con:

```
cat ~/.ssh/id_rsa.pub | ssh hugo@192.168.6.10 "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys"

```

### Verificar la autenticaci√≥n sin contrase√±a

Prueba iniciar sesi√≥n en el servidor sin que te pida la contrase√±a:

```
ssh hugo@192.168.6.10

```
<br>
<br>


## Recibir las copias a la carpeta destino

El comando sudo chown -R hugo:hugo /home/hugo/buckup cambia el propietario y el grupo de todos los archivos y subdirectorios dentro de /home/hugo/buckup al usuario hugo

```
sudo chown -R hugo:hugo /home/hugo/buckup

```

* sudo: Ejecuta el comando con privilegios de superusuario.

* chown: Cambia el propietario de un archivo o directorio.

* -R: Aplica el cambio de propietario de forma recursiva (a todos los archivos y subdirectorios dentro de /home/hugo/buckup).

* hugo:hugo : Establece el usuario propietario como hugo y el grupo como hugo.

* /home/hugo/buckup: Especifica la carpeta a la que se aplicar√° el cambio.

<br>


Establece permisos de lectura, escritura y ejecuci√≥n para el propietario, y solo lectura y ejecuci√≥n para el grupo y otros usuarios en los archivos dentro de /home/hugo/destino.

```
sudo chmod -R 755 /home/hugo/destino

```

* sudo: Ejecuta el comando con privilegios de superusuario.

* chmod: Modifica los permisos de archivos o directorios.

* -R: Aplica el cambio de permisos recursivamente a todos los archivos y subdirectorios dentro del directorio.

* 755: Establece los permisos de lectura, escritura y ejecuci√≥n para el propietario (7 = lectura, escritura y ejecuci√≥n), y solo lectura y ejecuci√≥n para el grupo y los otros usuarios (5 = lectura y ejecuci√≥n).

* /home/hugo/destino: Especifica la ruta del directorio al cual se le aplican los permisos.


<br>
<br>


## Recibir las copias a la carpeta de recuperaci√≥n

El comando sudo chown -R hugo:hugo /home/hugo/buckup cambia el propietario y el grupo de todos los archivos y subdirectorios dentro de /home/hugo/buckup al usuario hugo

```
sudo chown -R hugo:hugo /home/hugo/buckup

```

* sudo: Ejecuta el comando con privilegios de superusuario.

* chown: Cambia el propietario de un archivo o directorio.

* -R: Aplica el cambio de propietario de forma recursiva (a todos los archivos y subdirectorios dentro de /home/hugo/buckup).

* hugo:hugo : Establece el usuario propietario como hugo y el grupo como hugo.

* /home/hugo/buckup: Especifica la carpeta a la que se aplicar√° el cambio.

<br>
<br>


El comando sudo chmod -R u+w /home/hugo/buckup otorga permisos de escritura al usuario propietario en todos los archivos y subdirectorios dentro de /home/hugo/buckup, recursivamente.

```
sudo chmod -R u+w /home/hugo/buckup

```

* sudo: Ejecuta el comando con privilegios de superusuario.

* chmod: Modifica los permisos de archivos o directorios.

* -R: Aplica los cambios de permisos recursivamente.

* -u+w: Agrega permiso de escritura (+w) al usuario propietario (u).

* /home/hugo/buckup: Carpeta a la que se aplicar√° el cambio.


</details>
<br>



<details>
<summary>+----------üß±üî• PFSense</summary>

# ¬øQu√© es PFSense?
Es una distribuci√≥n de **FreeBSD** adaptada como **firewall** y **router**. Es de c√≥digo abierto y se puede instalar en dispositivos f√≠sicos y virtuales. Est√° respaldada comercialmente por **Electric Sheep Fencing LLC**, adem√°s de ser de c√≥digo abierto.
**PfSense** proporciona funciones avanzadas de seguridad y redes, y es conocida por ser una soluci√≥n de firewall de alto rendimiento. A continuaci√≥n, mostramos algunas caracter√≠sticas clave:



* **Firewall avanzado:** Permite configurar reglas de firewall para filtrar y controlar el tr√°fico de red de manera efectiva.
* **Enrutamiento:** Funciona como un router que proporciona funciones de enrutamiento avanzadas y permite la conectividad entre redes.
* **VPN:** Proporciona soporte para VPNs, permitiendo conexiones seguras a trav√©s de redes p√∫blicas.
* **Proxy y filtrado web:** Ofrece funciones de proxy y filtrado web para controlar el acceso a Internet y mejorar la seguridad.
* **Balanceo de carga y redundancia:** Permite distribuir el tr√°fico entre varios servidores y garantizar la disponibilidad en caso de fallos.
* **Seguridad:** Incluye herramientas y configuraciones avanzadas para asegurar las redes y proteger contra ataques.
* **Interfaz gr√°fica:** Cuenta con una interfaz web f√°cil de usar para gestionar y configurar el sistema de forma eficiente.


## Configuraci√≥n de la interfaz LAN

Para configurar la direcci√≥n IP de la interfaz LAN, seleccionamos la opci√≥n n√∫mero 2. A continuaci√≥n, los pasos que nos aparecer√°n:

1. Nos preguntar√° si queremos configurarlo v√≠a DHCP, debemos responder no.
2. A√±adimos la nueva direcci√≥n IP: **192.168.56.110**.
3. Nos preguntar√° qu√© m√°scara de subred utilizaremos: 24.
4. Luego presionamos **ENTER**
5. Nos preguntar√° si queremos configurar una direcci√≥n IPv6 en la interfaz LAN. Respondemos no y presionamos **ENTER**.
6. Luego nos preguntar√° si queremos habilitar un servidor DHCP en la LAN. Respondemos s√≠. A√±adimos el inicio del rango de IP para los clientes (**192.168.56.150**) y el final del rango (**192.168.56.160**).



## Configuraci√≥n de la interfaz WAN
La interfaz WAN se utiliza para conectarse a Internet. Normalmente, se configura con DHCP si el proveedor de servicios de Internet (ISP) asigna direcciones din√°micas, aunque tambi√©n se puede configurar con una IP est√°tica.

1. Desde el men√∫ principal, selecciona la opci√≥n
   
```
2) Set interface(s) IP address.
```

3. Selecciona la interfaz WAN, en este caso:

```
1 - WAN (em0 - dhcp)
```

3. Selecciona el tipo de configuraci√≥n IP:

  * DHCP: Si el ISP asigna la IP autom√°ticamente (opci√≥n recomendada para la mayor√≠a de los casos).

  * Est√°tica: Si tienes una IP fija proporcionada por tu ISP.

4. Si es IP est√°tica, introduce:

  * Direcci√≥n IP (por ejemplo, **```192.168.1.2```**).

  * M√°scara de subred (por ejemplo, **```255.255.255.0```**).

  * Puerta de enlace (IP del router del ISP, por ejemplo, ```192.168.1.1```).

5.¬øConfigurar IPv6?

  * Si tu ISP lo soporta, puedes configurarlo o dejarlo en autom√°tico.

6. ¬øActivar servidor DHCP en esta interfaz?

  * Para la interfaz WAN, generalmente seleccionamos No.

7. Confirmar y aplicar cambios.

<br>
<br>

## Configuraci√≥n de la interfaz LAN
La interfaz LAN se usa para la red interna y suele tener una direcci√≥n IP est√°tica.

1. Desde el men√∫ principal, selecciona ```2) Set interface(s) IP address```.

2. Selecciona la interfaz LAN, en este caso:

```
2 - LAN (em1 - static)
```

3. Configura la IP de LAN, por ejemplo:

* Direcci√≥n IP: ```192.168.1.1``` (IP del router dentro de la red local).

* M√°scara de subred: ```255.255.255.0```.

4. Configurar IPv6:

   Puedes desactivarlo si no lo necesitas o usarlo si tu red lo soporta.

6. ¬øActivar servidor DHCP en LAN?

* S√≠ (para que los dispositivos en la red obtengan IP autom√°ticamente).

* Especifica un rango de IPs, por ejemplo:

  * Inicio: ```192.168.1.100```

  * Fin: ```192.168.1.200```

6. Confirmar y aplicar cambios.



![image](https://github.com/user-attachments/assets/b3f88415-07a5-4233-b5e2-9fdbbb605306)

<br>
<br>
<br>
<br>

Para poder acceder a **pfSense** en modo gr√°fico, debes ingresar la direcci√≥n IP en el navegador de una m√°quina conectada a la red LAN, siempre que esta tenga habilitado el acceso al modo gr√°fico.

![image](https://github.com/user-attachments/assets/52450081-dc1d-4086-9f1c-1d48ce3d9e75)


Tendremos que activar **Kea DHCP**, que se encarga de asignar direcciones IP din√°micamente. Mejora el rendimiento, permite configuraciones sin necesidad de reiniciar, soporta bases de datos externas y facilita la administraci√≥n remota mediante API.

![image](https://github.com/user-attachments/assets/848e501c-bf3b-4d85-b0d3-725bb8bdb75e)

<br>
<br>

# ¬øQu√© es OpenVPN?

**OpenVPN** es una soluci√≥n de software libre para crear redes privadas virtuales (VPN). Permite establecer una conexi√≥n segura y cifrada entre dispositivos a trav√©s de una red no segura, como **Internet**. Es utilizado para proteger la privacidad en l√≠nea, asegurar la comunicaci√≥n entre dispositivos remotos y permitir el acceso a redes internas de forma segura.

![imagen_2025-03-14_101252810-removebg-preview](https://github.com/user-attachments/assets/e9237aa2-1a9e-4c13-a7f4-1e6642275050)

## ‚úÖ Ventajas
* **Seguridad robusta:** Utiliza cifrado de alta calidad (**AES, SSL/TLS**) para garantizar que los datos transmitidos est√©n protegidos contra intercepciones.

* **Flexibilidad:** Puede ser configurado para funcionar en diferentes plataformas (**Windows, Linux, macOS, Android, iOS**) y ser usado tanto en redes locales como remotas.

*  **C√≥digo abierto:** **OpenVPN** es gratuito y tiene una comunidad activa que contribuye a su mejora constante.

*  **Acceso remoto seguro:** Ideal para acceder de forma segura a redes privadas desde cualquier lugar del mundo.

*  **Escalabilidad:** Puede manejar desde peque√±as instalaciones hasta grandes redes corporativas.

## ‚ùå Desventajas
Desventajas de OpenVPN:
* **Configuraci√≥n compleja:** A pesar de ser poderoso, puede resultar complicado de configurar para usuarios sin experiencia, especialmente cuando se necesita ajustar opciones avanzadas.

* **Rendimiento:** En comparaci√≥n con otras soluciones **VPN**, **OpenVPN** puede ser m√°s lento debido a su nivel de cifrado y autenticaci√≥n, aunque este impacto es m√≠nimo si se utiliza un hardware adecuado.

* **Dependencia de certificados:** Requiere la gesti√≥n de certificados y claves para la autenticaci√≥n, lo que puede ser un desaf√≠o si no se tiene experiencia en su administraci√≥n.

* **Requiere software adicional:** Necesita instalar un cliente **OpenVPN** en los dispositivos que se conectan a la red privada, lo que puede ser una limitaci√≥n en algunos entornos.

<br>

# Com√≥ activar OpenVPN

## 1Ô∏è‚É£ Instalar OpenVPN (si no est√° instalado)

OpenVPN viene integrado en pfSense, pero si falta, inst√°lalo desde:

üîπ System > Package Manager > Available Packages > Busca ```OpenVPN``` > Install

## 2Ô∏è‚É£ Configurar el Servidor OpenVPN en pfSense

1. Accede a la interfaz web de pfSense en ```https://192.168.1.1```

<br>

2. Ve a VPN > OpenVPN > Wizards

<br>

3. Selecciona el m√©todo de autenticaci√≥n:

  * Local User Access (usuarios internos) o

  * LDAP/RADIUS (si usas autenticaci√≥n externa)

<br>

4. Crear o usar una **CA** (Certificate Authority)

  * Si no tienes una **CA**, el asistente la generar√°.

  * Crea un certificado de servidor.

<br>

5. Configurar el servidor VPN:

  * Interfaz: ```WAN```

  * Protocolo: ```UDP``` o ```TCP``` (recomendado UDP)

  * Puerto: ```1194``` (puedes cambiarlo)

  * Tunnel Network: ```10.8.0.0/24``` (rango IP de la VPN)

  * Local Network: ```192.168.1.0/24``` (red interna)

  * Activar ```Redirect Gateway``` si quieres que todo el tr√°fico pase por la VPN

<br>

6. Configurar cifrado y seguridad:

  * Cipher: AES-256-CBC o AES-256-GCM

  * Auth Digest Algorithm: SHA256

  * TLS Authentication: Activar

<br>

7. Guardar y aplicar los cambios.

## 3Ô∏è‚É£ Crear reglas de Firewall para OpenVPN

1. Ve a Firewall > Rules > OpenVPN

<br>

2. A√±ade una regla:

  * Acci√≥n: ```Pass```

  * Protocolo: ```Any```

  * Fuente: ```OpenVPN```

  * Destino: ```Any```

  * Guardar y aplicar.

Tambi√©n, en Firewall > NAT, agrega una regla para permitir tr√°fico desde la VPN.



## 4Ô∏è‚É£ Crear Usuarios y Certificados

1.Ve a System > User Manager

<br>

2. A√±ade un usuario, activa "Certificate" y genera uno nuevo.

## 5Ô∏è‚É£ Exportar el perfil OpenVPN para clientes

1. Instala el paquete OpenVPN Client Export desde System > Package Manager.

<br>

2. Ve a VPN > OpenVPN > Client Export.

<br>

3. Descarga el archivo ```.ovpn``` para conectarte desde Windows, macOS, Linux o m√≥viles.

## 6Ô∏è‚É£ Conectar un Cliente OpenVPN

* Instala OpenVPN Client en tu PC o m√≥vil.

* Importa el archivo ```.ovpn``` y con√©ctate.


<br>
<br>
<br>
<br><br>
<br>
<br>
<br><br>
<br>
<br>
<br>






</details>

<br>

<details>
<summary>+----------üîêüíªCifrado de punto a punto</summary>

# Qu√© es el Cifrado punto a punto

El cifrado punto a punto (tambi√©n conocido como cifrado **end-to-end**, o **E2EE**, por sus siglas en ingl√©s) es un m√©todo de seguridad de comunicaci√≥n que asegura que solo el emisor y el receptor de la informaci√≥n puedan leer los mensajes que se env√≠an entre ellos.

![image](https://github.com/user-attachments/assets/45ede1e2-9629-4226-bec5-d94b1ac05ed3)

<br>

En este tipo de cifrado:

1Ô∏è‚É£ El emisor cifra el mensaje con una clave antes de enviarlo.

2Ô∏è‚É£ El mensaje cifrado se transmite a trav√©s de internet o cualquier otra red, pero incluso si alguien intercepta el mensaje, no podr√° entenderlo, ya que no tiene la clave para descifrarlo.

3Ô∏è‚É£ El receptor usa su propia clave para descifrar el mensaje y leerlo.

Esto garantiza que, incluso si los servidores de la plataforma de comunicaci√≥n son hackeados o las comunicaciones son interceptadas en el camino, los mensajes seguir√°n siendo privados y solo podr√°n ser le√≠dos por las personas a quienes est√°n destinados.

<br>

# end-to-end/WebSocket
El cifrado punto a punto (end-to-end) en WebSocket se logra utilizando una capa de cifrado sobre la comunicaci√≥n WebSocket, asegurando que los datos sean cifrados en el cliente y solo descifrados en el servidor, o viceversa. Esto se puede lograr con TLS (Transport Layer Security), que es el est√°ndar de cifrado utilizado en protocolos como HTTPS.

## Pasos para habilitar cifrado punto a punto en WebSocket:

### 1Ô∏è‚É£ Usar WebSocket sobre WSS (WebSocket Secure)
Al igual que HTTPS para HTTP, WebSocket utiliza WSS para conexiones seguras (cifradas). La wss:// es la versi√≥n segura de WebSocket, que utiliza TLS para cifrar la comunicaci√≥n.
  * En el servidor WebSocket, debes configurar TLS.
  * En el cliente, debes usar wss:// en lugar de ws:// para que la conexi√≥n sea segura.

### 2Ô∏è‚É£ Configurar un servidor WebSocket con TLS 
Si est√°s utilizando un servidor como Node.js con ws o Socket.io, necesitar√°s un certificado SSL/TLS. Aqu√≠ hay un ejemplo b√°sico usando Node.js:

* **Instalaci√≥n:**
```
npm install ws
npm install https
```

* **C√≥digo del servidor con TLS:**
```
const https = require('https');
const fs = require('fs');
const WebSocket = require('ws');

// Cargar los certificados SSL/TLS
const server = https.createServer({
  cert: fs.readFileSync('path/to/certificate.pem'),
  key: fs.readFileSync('path/to/private-key.pem')
});

// Crear el servidor WebSocket
const wss = new WebSocket.Server({ server });

wss.on('connection', ws => {
  ws.on('message', message => {
    console.log('received: %s', message);
  });
  ws.send('Hello secure WebSocket!');
});

server.listen(8080, () => {
  console.log('Secure WebSocket server is running on wss://localhost:8080');
});
```

* **https.createServer()** se usa para crear un servidor HTTPS que tambi√©n soporta WebSocket seguro.
* Necesitar√°s tener un certificado (**certificate.pem**) y una clave privada (**private-key.pem**).

### 3Ô∏è‚É£ Cliente WebSocket con wss://
En el lado del cliente, simplemente usa wss:// para conectar de manera segura al servidor.

**C√≥digo del cliente:**

```
const socket = new WebSocket('wss://localhost:8080');

socket.onopen = function(event) {
  console.log('Conectado al servidor seguro WebSocket');
  socket.send('Hola desde el cliente seguro!');
};

socket.onmessage = function(event) {
  console.log('Mensaje recibido: ', event.data);
};
```

### 4Ô∏è‚É£ Certificados y claves en producci√≥n
* Para entornos de producci√≥n, aseg√∫rate de obtener certificados SSL/TLS v√°lidos de una autoridad de certificaci√≥n (CA) confiable.
* Usa herramientas como Let's Encrypt para obtener certificados SSL gratuitos si es necesario.

<br>

### Consideraciones adicionales
Cifrado de extremo a extremo real: Si deseas realizar un cifrado adicional de los datos antes de enviarlos a trav√©s de WebSocket (m√°s all√° de TLS), podr√≠as cifrar los mensajes con una clave privada del cliente y solo el destinatario podr√≠a descifrarlos. Para esto, puedes usar bibliotecas como CryptoJS o Web Crypto API.

**Ejemplo usando Web Crypto API en el cliente:**

```
async function encryptData(data, publicKey) {
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(data);

  // Usar la clave p√∫blica para cifrar los datos
  const encryptedData = await window.crypto.subtle.encrypt(
    { name: "RSA-OAEP" },
    publicKey,
    dataBuffer
  );

  return encryptedData;
}
```

### Resumen
1. Usa wss:// en lugar de ws:// para asegurarte de que los WebSockets est√©n cifrados usando TLS.

2. En el servidor, configura un certificado SSL/TLS para habilitar la conexi√≥n segura.

3. Si deseas un cifrado real punto a punto, implementa cifrado adicional de los datos (por ejemplo, usando RSA o AES en el lado del cliente y servidor).

<br>

## Ejemplos de aplicaciones que usan cifrado punto a punto:

* WhatsApp
* Signal
* Telegram (en chats secretos)
* iMessage

Este tipo de cifrado es muy popular porque ofrece un alto nivel de privacidad y seguridad, ya que ni siquiera los proveedores del servicio (como las plataformas de mensajer√≠a) tienen acceso a los contenidos de los mensajes.


<br>


## Protecci√≥n contra ataques punto a punto
Los ataques punto a punto en aplicaciones de chat implican que un atacante se haga con el control de las comunicaciones o manipule las conversaciones entre los usuarios.


### Cifrado de extremo a extremo (E2EE)
Para proteger los mensajes de ser interceptados y le√≠dos por atacantes, implementamos un cifrado de extremo a extremo (E2EE). Esto significa que los mensajes se cifran en el dispositivo del usuario y solo pueden ser descifrados en el dispositivo del receptor. Algunos enfoques incluyen:


   * E2EE en el cliente: Podr√≠amos utilizar bibliotecas como libsignal (que usa el protocolo Signal) o WebCrypto API para cifrar los mensajes en el cliente antes de enviarlos al servidor.

  * Algoritmos de cifrado recomendados: Podr√≠amos utilizar algoritmos como AES-256 para cifrar los mensajes y RSA o ECDSA para intercambiar claves de cifrado de forma segura.


### Protecci√≥n de las claves de cifrado
Las claves de cifrado deben almacenarse de forma segura y no deben estar en el c√≥digo fuente ni en el servidor de forma accesible. Utiliza almacenamiento seguro de claves, como Hardware Security Modules (HSM) o KMS (Key Management Systems) en proveedores como AWS o Google Cloud.



### Protecci√≥n de la transmisi√≥n de datos
Utilizariamos TLS/SSL para cifrar todas las comunicaciones entre el cliente y el servidor. Esto evitar√° que los datos sean interceptados mientras viajan por la red.


<br>


<details>
<summary>+---------- üîêüåÄüîë ChaCha20</summary>

## ¬øQu√© es ChaCha20?
ChaCha20 es un algoritmo de cifrado simetrico que pertenece a la familia de cifrados de flujo. Fue dise√±ado por el cript√≥grafo Daniel J. Bernstein en 2008 como una mejora de su predecesor, el algoritmo Salsa20. ChaCha20 fue creado con el objetivo de ofrecer una alta seguridad, velocidad y eficiencia, especialmente en sistemas que no cuentan con instrucciones de hardware dedicadas para acelerar los c√°lculos de cifrado.


  * Mejoras del ChaCha20 en comparaci√≥n al Salsa20:
    * Rondas de transformaci√≥n: ChaCha20 mejora Salsa20 al aumentar el n√∫mero de rondas de transformaci√≥n de 12 (en Salsa20) a 20. Esto mejora la seguridad al hacer que los datos sean m√°s dif√≠ciles de predecir o manipular en cada ronda de cifrado.

    * Modificaci√≥n en la funci√≥n de mezcla: Se realizaron peque√±os cambios en la estructura interna del algoritmo para mejorar la distribuci√≥n de bits y hacer el proceso de cifrado m√°s resistente a los ataques.

    * ChaCha20 se consider√≥ m√°s seguro que Salsa20, ya que ofrece un mejor nivel de aleatoriedad y tiene una mayor resistencia a ciertos ataques.


<br>


## Funcionamoento del ChaCha20
ChaCha20 es un cifrado de flujo, lo que significa que en lugar de cifrar bloques de datos como lo hace un cifrado de bloque (por ejemplo, AES), cifra los datos bit a bit, generando una secuencia de bits pseudoaleatorios que luego se combina con los datos mediante una operaci√≥n XOR.

  * Proceso b√°sico de funcionamiento de ChaCha20:

    1. Clave y nonce: ChaCha20 toma como entrada una clave de 256 bits (32 bytes) y un nonce de 64 bits (8 bytes). El nonce asegura que el flujo de claves generado es √∫nico para cada mensaje cifrado, evitando ataques por repetici√≥n de claves.

    2. Inicializaci√≥n: ChaCha20 utiliza un estado interno de 512 bits que se configura con la clave y el nonce. Este estado es una matriz de 16 enteros de 32 bits cada uno.

    3. Rondas: El algoritmo realiza 20 rondas de transformaci√≥n (frente a las 12 rondas de Salsa20). En cada ronda, el estado interno se somete a una serie de operaciones matem√°ticas (como rotaciones y adiciones) que mezclan los bits de manera compleja.

    4. Generaci√≥n de flujo: Tras las rondas, el estado se transforma en una secuencia de 64 bits que se usa como clave de flujo. Esta secuencia se combina con los datos mediante una operaci√≥n XOR para cifrar o descifrar los datos. El mismo proceso se usa para descifrar los datos, ya que el cifrado de flujo es reversible si se conoce la misma clave y nonce.


<br>


## Ejemplos de uso de ChaCha20
ChaCha20 es ampliamente utilizado en aplicaciones modernas que requieren cifrado eficiente y seguro. Algunos de los ejemplos m√°s comunes son:

  * **TLS 1.3:** En el protocolo TLS 1.3 (usado para asegurar las comunicaciones en internet, como en HTTPS), ChaCha20 se utiliza como una opci√≥n para cifrar la comunicaci√≥n, en lugar de AES. Esto es particularmente √∫til cuando el hardware de los dispositivos no soporta aceleraci√≥n de AES.

  * **WireGuard:** WireGuard es un protocolo de VPN (Red Privada Virtual) que utiliza ChaCha20 para cifrar el tr√°fico de red entre los dispositivos conectados. La raz√≥n por la que se utiliza ChaCha20 en lugar de otros algoritmos m√°s tradicionales, como AES, es que ChaCha20 es m√°s r√°pido y eficiente en dispositivos sin aceleraci√≥n de hardware.
  
  * **Signal:** La aplicaci√≥n de mensajer√≠a segura Signal utiliza ChaCha20-Poly1305 para cifrar los mensajes entre los usuarios. Poly1305 se usa para asegurar la integridad y autenticidad del mensaje, proporcionando tanto confidencialidad como autenticidad.
  
  * **Google Chrome y otros navegadores:** ChaCha20 tambi√©n es soportado por algunos navegadores modernos como Google Chrome en combinaci√≥n con TLS 1.3 para cifrar las conexiones HTTPS, especialmente en dispositivos m√≥viles y otras plataformas que no tienen soporte de hardware para AES.


<br>


## Ventajas de ChaCha20

  * **Seguridad robusta:** Gracias a las 20 rondas de cifrado y su dise√±o matem√°ticamente s√≥lido, ChaCha20 es muy seguro frente a una variedad de ataques criptogr√°ficos.
  
  * **Velocidad en software:** ChaCha20 es extremadamente r√°pido en software, lo que lo hace ideal para dispositivos m√≥viles y otros sistemas sin aceleraci√≥n de hardware como AES-NI.
  
  * **Resistencia a backdoors:** No depende de instrucciones de hardware espec√≠ficas, lo que lo hace m√°s dif√≠cil de comprometer a trav√©s de vulnerabilidades en hardware, un factor de seguridad importante en el contexto de la privacidad.
  
  * **Facilidad de implementaci√≥n:** ChaCha20 es relativamente f√°cil de implementar correctamente, lo que reduce el riesgo de errores en su integraci√≥n en aplicaciones.


## Desventajas

  * **No tan ampliamente adoptado como AES:**
    * Aunque est√° ganando terreno, AES sigue siendo el est√°ndar m√°s utilizado en muchas aplicaciones y hardware.
    * Algunos sistemas o bibliotecas antiguas podr√≠an no tener soporte para ChaCha20 de forma nativa.
  
  * **No tiene soporte por hardware tan extendido:**
    * AES puede aprovechar instrucciones espec√≠ficas del procesador (AES-NI) para hacerlo extremadamente r√°pido en muchos dispositivos.
    * ChaCha20, aunque r√°pido en software, no tiene soporte por hardware dedicado en la mayor√≠a de CPUs.

  * **No es adecuado para todos los casos de uso criptogr√°fico:**
    * ChaCha20 es un stream cipher, por lo que no tiene modos de operaci√≥n como CBC o GCM propios.
    * Se suele usar con Poly1305 para autenticaci√≥n (ChaCha20-Poly1305), pero eso requiere una implementaci√≥n conjunta segura.
  
  * **Mayor tama√±o de nonce en algunas implementaciones:**
    * ChaCha20 requiere un nonce de 96 bits (12 bytes). Esto no es un problema en la mayor√≠a de los casos, pero puede ser inconveniente si est√°s migrando desde algoritmos que usan tama√±os de nonce diferentes.

<br>


## Comparaci√≥n con otros algoritmos
  
  * **ChaCha20 vs. AES:**
    * AES es un algoritmo de cifrado de bloque, mientras que ChaCha20 es un cifrado de flujo. Esto significa que ChaCha20 puede ser m√°s eficiente para cifrar datos de longitud variable sin la necesidad de padding (relleno).
    * Aunque AES es muy seguro, su rendimiento puede ser m√°s lento en plataformas sin soporte de hardware como AES-NI. ChaCha20, por otro lado, ofrece un rendimiento constante incluso en plataformas con recursos limitados.
  
  * **ChaCha20 vs. Salsa20:**
    * ChaCha20 es una mejora sobre Salsa20, con m√°s rondas de cifrado (20 en lugar de 12) y una estructura m√°s robusta que lo hace m√°s seguro frente a ciertos ataques. ChaCha20 tambi√©n es m√°s resistente a ciertos tipos de colisiones, lo que aumenta su nivel de seguridad.


<br>


## ChaCha20 en E2EE

  1. **Alta seguridad:**
    * ChaCha20 ha sido dise√±ado para ser resistente a ataques criptogr√°ficos. Tiene 20 rondas de cifrado, lo que lo hace m√°s seguro que su predecesor, Salsa20. Adem√°s, ha pasado por una extensa revisi√≥n acad√©mica y pr√°ctica, lo que lo convierte en una opci√≥n muy confiable.
  
  2. **Velocidad y eficiencia:**
    * ChaCha20 es muy eficiente en software, lo que es una gran ventaja en dispositivos m√≥viles o plataformas sin aceleraci√≥n de hardware (como en muchos tel√©fonos inteligentes, tabletas o dispositivos IoT). A diferencia de AES, que puede depender de instrucciones especializadas de hardware (como AES-NI), ChaCha20 es r√°pido incluso en plataformas que no tienen esas optimizaciones, lo que lo hace ideal para aplicaciones de E2EE en dispositivos con recursos limitados.
  
  3. **Resistencia a vulnerabilidades de hardware:**
    * ChaCha20 no depende de instrucciones de hardware espec√≠ficas, lo que lo hace menos vulnerable a posibles vulnerabilidades relacionadas con implementaciones de hardware o backdoors, una preocupaci√≥n que a veces se menciona con respecto a otros algoritmos como AES.
  
  4. **F√°cil de implementar:**
    * Comparado con otros algoritmos como AES, ChaCha20 tiene un dise√±o m√°s simple, lo que reduce la posibilidad de errores en la implementaci√≥n. En sistemas de E2EE, donde la seguridad depende de la implementaci√≥n correcta del cifrado, esto es un factor muy importante.


<br>


## ¬øC√≥mo se usa ChaCha20 en E2EE?
En un sistema de E2EE, los datos se cifran en el dispositivo del emisor antes de ser enviados y solo el receptor puede descifrarlos. Aqu√≠ es donde entra en juego ChaCha20 como algoritmo de cifrado:

  1. **Cifrado de los datos:**
    * ChaCha20 utiliza una clave secreta (generalmente de 256 bits) y un nonce (n√∫mero √∫nico que garantiza que cada cifrado sea √∫nico). Usando estos, genera una secuencia de bits pseudoaleatorios que se combinan con los datos a cifrar mediante una operaci√≥n XOR, produciendo el texto cifrado.
  
  2. **Integraci√≥n con autenticaci√≥n:**
    * ChaCha20 generalmente se combina con un algoritmo de autenticaci√≥n como Poly1305 para garantizar no solo la confidencialidad, sino tambi√©n la integridad de los datos. Esto se denomina ChaCha20-Poly1305. Este enfoque asegura que los datos no hayan sido alterados en el camino y permite a los receptores verificar la autenticidad de los mensajes.
  
  3. **Uso en aplicaciones populares:**
    * Algunos ejemplos de su uso son WireGuard (una tecnolog√≠a de VPN) y Signal (una aplicaci√≥n de mensajer√≠a segura), que utilizan ChaCha20 para cifrar y asegurar las comunicaciones de extremo a extremo.


<br>

## Video de la explicaci√≥n del algoritmo ChaCha20:
https://youtu.be/LIvFSppLDnM?si=Ss0pJPd-QsCV2tyC


## Funci√≥n en Cyberchef

Necesitamos una clave de 256 bits en Hexadecimal: **00112233445566778899aabbccddeeff00112233445566778899aabbccddeeff**

Un nonce de Base64: **0102030405060708**

Counter: **00000000**

Rounds: **20**

* Texto --> Hola, como estan gente.
* C√≥digo HEX --> 9b 49 04 2e 83 09 d1 5f 2d 56 6e 52 d0 44 79 13 43 f6 b3 24 c2 2f 08

![image](https://github.com/user-attachments/assets/6beadd52-ff43-4d7a-bcb1-932aa73dd605)


<br>


## Ventajas de usar ChaCha20 en E2EE

  * **Eficiencia:** Funciona bien en plataformas con recursos limitados, como tel√©fonos m√≥viles y dispositivos sin aceleraci√≥n de hardware.

  * **Seguridad robusta:** Ofrece un alto nivel de seguridad frente a los ataques conocidos.

  * **Simplificaci√≥n de la implementaci√≥n:** Su dise√±o es m√°s simple, lo que reduce el riesgo de errores en la implementaci√≥n del cifrado.


</details>
</details>

<details>
<summary>+---------- üí•‚öîÔ∏èPosibles ataques</summary>

## ![image](https://github.com/user-attachments/assets/6b426a14-1c83-4c62-b4f8-505d01d448eb) Ataques de Hydra

### Protecci√≥n contra ataques de Hydra
Los ataques de fuerza bruta como Hydra se realizan para adivinar contrase√±as o credenciales de usuario mediante un proceso automatizado que intenta miles o millones de combinaciones. Aqu√≠ os mostraremos como podemos evitar algunos de estos ataques:

1. Implementar un sistema de autenticaci√≥n robusto
    * Utiliza autenticaci√≥n multifactor (MFA): Agregar una capa adicional de seguridad con c√≥digos enviados por SMS, correos electr√≥nicos o aplicaciones como Google Authenticator.

    * Implementa l√≠mites de intentos fallidos de inicio de sesi√≥n: Despu√©s de varios intentos fallidos de iniciar sesi√≥n (por ejemplo, 3 o 5 intentos), bloquea la cuenta temporalmente o requiere CAPTCHA.
   
    * Usa contrase√±as fuertes: En nuestro sistema de registro y cambio de contrase√±as, aplicamos reglas estrictas para crear contrase√±as seguras, como la inclusi√≥n de caracteres especiales, may√∫sculas, min√∫sculas y n√∫meros.



2. CAPTCHA y reCAPTCHA
    * reCAPTCHA de Google es una excelente herramienta para asegurarte de que las solicitudes de inicio de sesi√≥n o registro no provengan de bots. Implementar un sistema de CAPTCHA en el formulario de inicio de sesi√≥n puede dificultar un ataque de fuerza bruta.

    * Script:
   ```
   <script src="https://www.google.com/recaptcha/api.js" async defer></script>
   <form action="..." method="POST">
      <div class="g-recaptcha" data-sitekey="tu_clave_del_sitio"></div>
      <input type="submit" value="Iniciar sesi√≥n">
   </form>
   ```


3. Almacenamiento seguro de contrase√±as

    * Usar hashing de contrase√±as con algoritmos seguros como bcrypt o argon2 en lugar de almacenarlas en texto plano.
    * Salts: A√±adir un salt √∫nico por cada contrase√±a para prevenir ataques como rainbow tables.


<br>

## üíâüçÉ Inyecciones MongoDB

### Prevenci√≥n de Inyecciones en MongoDB
Las inyecciones son ataques en los que los datos de los usuarios se manipulan para ejecutar comandos maliciosos en la base de datos. Aunque MongoDB es m√°s seguro contra las inyecciones que SQL, a√∫n es vulnerable si no se toman las precauciones adecuadas. Ahora os mostraremos que prevenciones podemos utilizar para evitar inyecciones en nuestra BBDD MongoDB:

1. Usar consultas parametrizadas
Nos aseg√∫ramos de que todas las consultas a la base de datos est√©n parametrizadas y no interpolen directamente datos de los usuarios en las consultas. En lugar de construir consultas din√°micas concatenando cadenas de texto, usamos las consultas adecuadas con filtros expl√≠citos.
  
    * Script:
  
    ```
    db.users.find({ "username": username });
    ```



2. Validaci√≥n de entradas de usuario
Antes de almacenar cualquier dato en MongoDB, validamos y limpiamos todas las entradas. Podemos utilizar librer√≠as como Joi o express-validator para asegurarnos de que los datos cumplen con el formato esperado.

    * Nos aseguramos de que los datos de entrada no contengan caracteres especiales o comandos que puedan ser interpretados como parte de una consulta.



3. Desactivar funciones peligrosas de MongoDB
Algunas funciones, como eval(), permiten la ejecuci√≥n de c√≥digo JavaScript dentro de MongoDB. Nos tenemos que asegurar de desactivar funciones peligrosas en la configuraci√≥n de nuestro servidor MongoDB.

    * Ejemplo de script:
    ```
    # En el archivo de configuraci√≥n mongod.conf
    security:
      javascriptEnabled: false
    ```



4. Limitar permisos de acceso
Configura roles y permisos en MongoDB para asegurarte de que las aplicaciones o usuarios solo tengan acceso a las bases de datos y colecciones que realmente necesitan. Utilizamos el modelo de control de acceso basado en roles (RBAC) de MongoDB.



5. Evitar la exposici√≥n p√∫blica de MongoDB
No hay que dejar la bbdd MongoDB accesible desde internet sin una capa de protecci√≥n. Usa firewalls para restringir el acceso solo a las direcciones IP autorizadas.

    * Script:
    ```
    net:
      bindIp: 127.0.0.1  # Solo permite conexiones locales
    ```


<br>
  
</details>

<details>
<summary>+---------- üîê#Ô∏è‚É£Hash</summary>

## hashcat ‚Äì como herramienta  para romper hashes
    
Una herramienta para romper hashes intenta descubrir el valor original de un hash usando t√©cnicas como fuerza bruta, diccionario o ataques por arco iris. Compara m√∫ltiples entradas cifradas con el hash objetivo hasta hallar coincidencias, aprovechando debilidades o patrones comunes en contrase√±as.




## Generar hashes en python 

### hashlib

Funci√≥n:

Es el m√≥dulo est√°ndar de Python para generar hashes como MD5, SHA-256 y SHA-512.

Uso en el c√≥digo:

Se usa cuando no se necesita un salt o se desea generar un hash b√°sico:

Uso en el c√≥digo:

Se usa cuando no se necesita un salt o se desea generar un hash b√°sico:

```
hashlib.md5(password.encode()).hexdigest()
hashlib.sha256(password.encode()).hexdigest()
hashlib.sha512(password.encode()).hexdigest()
```


### Secrets

Funci√≥n:

Genera datos aleatorios seguros, ideal para generar salts.

Uso en el c√≥digo:

Se utiliza para generar un salt aleatorio si el usuario elige esa opci√≥n:

```
secrets.token_hex(4)  # genera un salt aleatorio de 8 caracteres hexadecimales
```


‚ÄÉ
### passlib.hash


Funci√≥n:

Permite aplicar algoritmos de hash m√°s complejos con soporte para salt y rounds (iteraciones).

Uso en el c√≥digo:

Se usan estas tres variantes del m√≥dulo passlib.hash:

* md5_crypt ‚Äì Para MD5 con salt.

* sha256_crypt ‚Äì SHA-256 con salt y rounds.

* sha512_crypt ‚Äì SHA-512 con salt y rounds.

Ejemplo:

```
sha512_crypt.using(salt=salt, rounds=5000).hash(password)
```

<details>
  <summary>üì¶üêçCod√≠go de Python para el Hash</summary>


Este c√≥digo es una aplicaci√≥n gr√°fica en Python (Tkinter) que permite:

üß™ Generar hashes (md5, sha256, sha512) con o sin salt (manual o aleatorio).

üß© Romper hashes usando un ataque de diccionario o una contrase√±a manual.

üìã Puedes copiar o guardar el hash generado.

Pantallas principales:

* "Generar Hashes": escribes una contrase√±a, eliges el tipo de hash, y genera el resultado.

* "Romper Hashes": introduces un hash y prueba contrase√±as desde un diccionario o manualmente.


```
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import hashlib
import secrets
import pyperclip
from passlib.hash import md5_crypt, sha256_crypt, sha512_crypt

class HashToolApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Herramienta de Hashes Avanzada")
        self.root.geometry("900x650")
        
        # Variables
        self.password_var = tk.StringVar()
        self.salt_var = tk.StringVar()
        self.use_salt_var = tk.BooleanVar(value=True)
        self.auto_salt_var = tk.BooleanVar(value=False)
        self.hash_type_var = tk.StringVar(value="sha512")
        self.rounds_var = tk.IntVar(value=5000)
        self.dict_path_var = tk.StringVar(value="diccionario.txt")
        self.use_dict_var = tk.BooleanVar(value=True)
        self.target_hash_var = tk.StringVar()
        self.single_password_var = tk.StringVar()
        
        # Notebook
        self.notebook = ttk.Notebook(root)
        self.tab_generate = ttk.Frame(self.notebook)
        self.tab_crack = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_generate, text="Generar Hashes")
        self.notebook.add(self.tab_crack, text="Romper Hashes")
        self.notebook.pack(expand=True, fill="both")
        
        # Pesta√±a Generar
        self.setup_generate_tab()
        
        # Pesta√±a Romper
        self.setup_crack_tab()
    
    def setup_generate_tab(self):
        frame = ttk.LabelFrame(self.tab_generate, text="Generar Hash", padding=10)
        frame.pack(pady=10, padx=10, fill="both", expand=True)
        
        # Controles
        ttk.Label(frame, text="Contrase√±a:").grid(row=0, column=0, sticky="e")
        ttk.Entry(frame, textvariable=self.password_var).grid(row=0, column=1, pady=5, sticky="ew")
        
        # Opciones de Salt
        salt_frame = ttk.LabelFrame(frame, text="Opciones de Salt", padding=5)
        salt_frame.grid(row=1, column=0, columnspan=2, pady=5, sticky="ew")
        
        ttk.Checkbutton(salt_frame, text="Usar Salt", variable=self.use_salt_var).pack(anchor="w")
        ttk.Checkbutton(salt_frame, text="Generar Salt Aleatorio", variable=self.auto_salt_var, 
                       command=self.toggle_salt_entry).pack(anchor="w")
        ttk.Label(salt_frame, text="Salt Personalizado:").pack(anchor="w")
        self.salt_entry = ttk.Entry(salt_frame, textvariable=self.salt_var, state="normal")
        self.salt_entry.pack(fill="x", pady=2)
        
        # Tipo de Hash
        ttk.Label(frame, text="Tipo de Hash:").grid(row=2, column=0, sticky="e")
        ttk.Combobox(frame, textvariable=self.hash_type_var, 
                    values=["md5", "sha256", "sha512"]).grid(row=2, column=1, pady=5, sticky="ew")
        
        ttk.Label(frame, text="Rounds (SHA-256/512):").grid(row=3, column=0, sticky="e")
        ttk.Entry(frame, textvariable=self.rounds_var).grid(row=3, column=1, pady=5, sticky="ew")
        
        ttk.Button(frame, text="Generar Hash", command=self.generate_hash).grid(row=4, column=0, columnspan=2, pady=10)
        
        # Resultado
        ttk.Label(frame, text="Hash Generado:").grid(row=5, column=0, sticky="ne")
        
        self.hash_text = tk.Text(frame, height=5, wrap="word", state="disabled", font=('Courier', 10))
        scrollbar = ttk.Scrollbar(frame, command=self.hash_text.yview)
        self.hash_text.configure(yscrollcommand=scrollbar.set)
        
        self.hash_text.grid(row=5, column=1, sticky="ew", pady=5)
        scrollbar.grid(row=5, column=2, sticky="ns")
        
        # Botones de acci√≥n
        button_frame = ttk.Frame(frame)
        button_frame.grid(row=6, column=1, pady=5, sticky="e")
        
        ttk.Button(button_frame, text="Copiar Hash", command=self.copy_hash).pack(side="left", padx=5)
        ttk.Button(button_frame, text="Descargar TXT", command=self.download_hash).pack(side="left", padx=5)
    
    def setup_crack_tab(self):
        frame = ttk.LabelFrame(self.tab_crack, text="Romper Hash", padding=10)
        frame.pack(pady=10, padx=10, fill="both", expand=True)
        
        # Hash objetivo
        ttk.Label(frame, text="Hash a Romper:").grid(row=0, column=0, sticky="e")
        ttk.Entry(frame, textvariable=self.target_hash_var).grid(row=0, column=1, pady=5, sticky="ew")
        
        # Opciones de Salt
        ttk.Label(frame, text="Salt (si aplica):").grid(row=1, column=0, sticky="e")
        ttk.Entry(frame, textvariable=self.salt_var).grid(row=1, column=1, pady=5, sticky="ew")
        
        # Tipo de Hash
        ttk.Label(frame, text="Tipo de Hash:").grid(row=2, column=0, sticky="e")
        ttk.Combobox(frame, textvariable=self.hash_type_var, 
                     values=["md5", "sha256", "sha512"]).grid(row=2, column=1, pady=5, sticky="ew")
        
        # M√©todo de ataque
        attack_frame = ttk.LabelFrame(frame, text="M√©todo de Ataque", padding=5)
        attack_frame.grid(row=3, column=0, columnspan=2, pady=5, sticky="ew")
        
        ttk.Radiobutton(attack_frame, text="Usar Diccionario (diccionario.txt)", variable=self.use_dict_var, 
                        value=True).pack(anchor="w")
        dict_subframe = ttk.Frame(attack_frame)
        dict_subframe.pack(fill="x", padx=20)
        ttk.Label(dict_subframe, text="Ruta:").pack(side="left")
        ttk.Entry(dict_subframe, textvariable=self.dict_path_var).pack(side="left", fill="x", expand=True)
        ttk.Button(dict_subframe, text="Examinar", command=self.select_dictionary).pack(side="left")
        
        ttk.Radiobutton(attack_frame, text="Probar Contrase√±a Manual", variable=self.use_dict_var,
                        value=False).pack(anchor="w")
        ttk.Entry(attack_frame, textvariable=self.single_password_var).pack(fill="x", pady=2)
        
        ttk.Button(frame, text="Iniciar Ataque", command=self.crack_hash).grid(row=4, column=0, columnspan=2, pady=10)
        
        # Resultado
        self.result_text = tk.Text(frame, height=10, state="disabled")
        self.result_text.tag_config("success", foreground="green")
        self.result_text.tag_config("error", foreground="red")
        self.result_text.grid(row=5, column=0, columnspan=2, sticky="ew")
    
    def toggle_salt_entry(self):
        if self.auto_salt_var.get():
            self.salt_entry.config(state="disabled")
            self.salt_var.set(secrets.token_hex(4))  # 4 bytes = 8 caracteres hex
        else:
            self.salt_entry.config(state="normal")
    
    def generate_hash(self):
        password = self.password_var.get()
        if not password:
            messagebox.showerror("Error", "Ingresa una contrase√±a.")
            return
        
        salt = self.salt_var.get() if self.use_salt_var.get() else None
        hash_type = self.hash_type_var.get()
        rounds = self.rounds_var.get()
        
        try:
            if hash_type == "md5" and salt:
                if len(salt) > 8:
                    messagebox.showerror("Error", 
                        "MD5 no soporta salts de m√°s de 8 caracteres.\n"
                        "Por favor usa un salt m√°s corto o selecciona otro algoritmo.")
                    return
                
                salt = salt[:8]
                hash_result = md5_crypt.using(salt=salt).hash(password)
            
            elif hash_type == "md5":
                hash_result = hashlib.md5(password.encode()).hexdigest()
            
            elif hash_type == "sha256":
                if salt:
                    hash_result = sha256_crypt.using(salt=salt, rounds=rounds).hash(password)
                else:
                    hash_result = hashlib.sha256(password.encode()).hexdigest()
            
            elif hash_type == "sha512":
                if salt:
                    hash_result = sha512_crypt.using(salt=salt, rounds=rounds).hash(password)
                else:
                    hash_result = hashlib.sha512(password.encode()).hexdigest()
            
            self.hash_text.config(state="normal")
            self.hash_text.delete(1.0, tk.END)
            self.hash_text.insert(tk.END, hash_result)
            self.hash_text.config(state="disabled")
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al generar hash: {e}")
    
    def copy_hash(self):
        hash_content = self.hash_text.get(1.0, tk.END).strip()
        if hash_content:
            pyperclip.copy(hash_content)
            messagebox.showinfo("Copiado", "Hash copiado al portapapeles.")
    
    def download_hash(self):
        hash_content = self.hash_text.get(1.0, tk.END).strip()
        if not hash_content:
            messagebox.showerror("Error", "No hay hash generado para descargar.")
            return
        
        file_path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Archivos de texto", "*.txt"), ("Todos los archivos", "*.*")],
            title="Guardar hash como"
        )
        
        if file_path:
            try:
                with open(file_path, "w") as f:
                    f.write(hash_content)
                messagebox.showinfo("√âxito", f"Hash guardado correctamente en:\n{file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"No se pudo guardar el archivo:\n{str(e)}")
    
    def select_dictionary(self):
        filepath = filedialog.askopenfilename(
            title="Seleccionar diccionario",
            filetypes=[("Archivos de texto", "*.txt"), ("Todos los archivos", "*.*")],
            initialfile="diccionario.txt"
        )
        if filepath:
            self.dict_path_var.set(filepath)
    
    def crack_hash(self):
        self.result_text.config(state="normal")
        self.result_text.delete(1.0, tk.END)
        
        target_hash = self.target_hash_var.get().strip()
        if not target_hash:
            self.show_error_message("‚ùå Debes ingresar un hash objetivo")
            return
        
        salt = self.salt_var.get() if self.use_salt_var.get() else None
        hash_type = self.hash_type_var.get()

        if self.use_dict_var.get():
            dict_path = self.dict_path_var.get()
            if not dict_path:
                self.show_error_message("‚ùå Debes seleccionar un archivo de diccionario")
                return
            
            try:
                with open(dict_path, "r", encoding="utf-8", errors="ignore") as f:
                    passwords = [line.strip() for line in f if line.strip()]
                    
                    self.result_text.insert(tk.END, f"üîç Buscando en {dict_path} ({len(passwords)} contrase√±as)...\n")
                    self.root.update()
                    
                    found = False
                    for i, password in enumerate(passwords, 1):
                        if self.check_password(password, target_hash, salt, hash_type):
                            found = True
                            break
                        
                        if i % 50 == 0:
                            self.result_text.insert(tk.END, f"‚è≥ Progreso: {i}/{len(passwords)}...\n")
                            self.result_text.see(tk.END)
                            self.root.update()
                    
                    if not found:
                        self.show_error_message("‚ùå Contrase√±a no encontrada en el diccionario")
            
            except FileNotFoundError:
                self.show_error_message(f"‚ùå Archivo no encontrado: {dict_path}")
            except Exception as e:
                self.show_error_message(f"‚ùå Error al leer el diccionario: {str(e)}")
        
        else:
            password = self.single_password_var.get().strip()
            if not password:
                self.show_error_message("‚ùå Ingresa una contrase√±a para probar")
                return
            
            self.check_password(password, target_hash, salt, hash_type)
    
    def check_password(self, password, target_hash, salt, hash_type):
        try:
            if hash_type == "md5":
                if salt:
                    salt = salt[:8]
                    current_hash = md5_crypt.using(salt=salt).hash(password)
                else:
                    current_hash = hashlib.md5(password.encode()).hexdigest()
                
                if current_hash == target_hash:
                    self.show_success_message(f"‚úÖ ¬°√âxito! Contrase√±a encontrada: {password}")
                    return True
            
            elif hash_type == "sha256":
                if salt:
                    current_hash = sha256_crypt.using(salt=salt).hash(password)
                else:
                    current_hash = hashlib.sha256(password.encode()).hexdigest()
                
                if current_hash == target_hash:
                    self.show_success_message(f"‚úÖ ¬°√âxito! Contrase√±a encontrada: {password}")
                    return True
            
            elif hash_type == "sha512":
                if target_hash.startswith('$6$'):
                    if not salt and len(target_hash.split('$')) >= 3:
                        salt = target_hash.split('$')[2]
                    
                    if salt:
                        current_hash = sha512_crypt.using(salt=salt, rounds=5000).hash(password)
                        
                        if current_hash == target_hash or current_hash.split('$')[-1] == target_hash.split('$')[-1]:
                            self.show_success_message(f"‚úÖ ¬°√âxito! Contrase√±a encontrada: {password}")
                            return True
                
                current_hash = hashlib.sha512(password.encode()).hexdigest()
                if current_hash == target_hash:
                    self.show_success_message(f"‚úÖ ¬°√âxito! Contrase√±a encontrada: {password}")
                    return True
            
            return False
        
        except Exception as e:
            self.show_error_message(f"‚ùå Error durante la verificaci√≥n: {str(e)}")
            return False
    
    def show_success_message(self, message):
        self.result_text.config(state="normal")
        self.result_text.insert(tk.END, message + "\n", "success")
        self.result_text.see(tk.END)
        self.result_text.config(state="disabled")
        messagebox.showinfo("√âxito", message)
    
    def show_error_message(self, message):
        self.result_text.config(state="normal")
        self.result_text.insert(tk.END, message + "\n", "error")
        self.result_text.see(tk.END)
        self.result_text.config(state="disabled")
        messagebox.showerror("Error", message)

if __name__ == "__main__":
    root = tk.Tk()
    app = HashToolApp(root)
    root.mainloop()
```

</details>


## Generar hashes de contrase√±as Linux con OpenSSL

OpenSSL es una herramienta de l√≠nea de comandos usada para implementar protocolos de seguridad como SSL/TLS. Sirve para generar claves, certificados, cifrar datos, crear hashes y gestionar conexiones seguras. Es esencial para proteger comunicaciones, autenticar identidades y asegurar archivos en sistemas Linux y servidores web.

```
openssl passwd -6 -salt SALT CONTRASE√ëA
```

* -6 ‚Üí Usa SHA-512 (-5 para SHA-256, -1 para MD5)

* -salt SALT ‚Üí Opcional. Puedes dejarlo y OpenSSL genera uno aleatorio.

* CONTRASE√ëA ‚Üí La contrase√±a que quieres hashear




## Hash vs KDF

Un hash transforma datos en una cadena fija e irrepetible para verificar integridad. 


Un KDF (Key Derivation Function) genera claves seguras a partir de contrase√±as, usando hash + sal y m√∫ltiples rondas. KDFs son m√°s resistentes a ataques por fuerza bruta que un hash simple.


Funci√≥n	Ventajas	Desventajas

Hash	- Muy r√°pido y eficiente

- F√°cil de implementar

- √ötil para integridad de datos	- No seguro para contrase√±as

- Vulnerable a ataques de diccionario o fuerza bruta


KDF	- Seguro para contrase√±as

- Usa sal y rondas para mayor resistencia

- Previene ataques de fuerza bruta	- M√°s lento por dise√±o

-  M√°s complejo de implementar


</details>





<br>




</details>


<br>


<details>
  <summary>üíæüçÉ Base de Datos</summary>
  
# Mongo DB

## ¬øQu√© es el Mongo DB?

MongoDB es una base de datos NoSQL orientada a documentos, dise√±ada para manejar grandes vol√∫menes de datos de manera flexible y escalable. A diferencia de las bases de datos relacionales tradicionales (como MySQL o PostgreSQL), MongoDB no usa tablas ni filas, sino que almacena los datos en documentos JSON (BSON, espec√≠ficamente).

![image](https://github.com/user-attachments/assets/7576c635-9443-4c87-a9fd-b5f92e74c768)

<br>

## ¬øPorqu√© estmos utilizando MongoDB y no MySQL?
Elegir MongoDB en lugar de MySQL para tu proyecto de chat estilo Telegram tiene varias ventajas, especialmente en cuanto a la flexibilidad, escalabilidad y desempe√±o en situaciones que requieren alta disponibilidad y rendimiento.

<br>

## üîπ Principales Caracter√≠sticas de MongoDB
    
1Ô∏è‚É£ **Base de datos NoSQL**

  * No utiliza estructuras relacionales (tablas y filas).
  
  * En su lugar, almacena datos en documentos JSON dentro de colecciones.

<br>

2Ô∏è‚É£ **Flexible y escalable**

  * No necesita una estructura fija de datos (esquema flexible).
  
  * Puede escalar horizontalmente (a√±adiendo m√°s servidores) con Sharding.

<br>

3Ô∏è‚É£ **Alto rendimiento**

* Soporta grandes vol√∫menes de datos con lecturas y escrituras r√°pidas.

<br>

4Ô∏è‚É£ **Soporte para consultas avanzadas**

* Puedes hacer consultas complejas con filtros, agregaciones y b√∫squedas avanzadas.

<br>

5Ô∏è‚É£ **Integraci√≥n con m√∫ltiples lenguajes**

* Compatible con Python, JavaScript (Node.js), Java, PHP, etc.

<br>
<br>


## üîπ Ejemplo de c√≥mo funciona MongoDB

üìå Estructura de un documento en MongoDB (similar a un JSON):

```
{
  "_id": ObjectId("60d5f9f4f3a2a2b6c8e5a123"),
  "nombre": "Juan P√©rez",
  "edad": 30,
  "ciudad": "Madrid",
  "hobbies": ["f√∫tbol", "cine", "lectura"]
}
```
* Se almacena dentro de una colecci√≥n (como una tabla en SQL).
* Cada documento puede tener una estructura diferente dentro de la misma colecci√≥n.

<br>
<br>

## üîπ Comparaci√≥n con una Base de Datos Relacional (SQL)

![image](https://github.com/user-attachments/assets/58e22335-33ae-4e32-9479-8e75327e0e6f)

<br>
<br>

## üîπ ¬øCu√°ndo usar MongoDB?

‚úÖ Cuando necesitas manejar grandes vol√∫menes de datos no estructurados.

‚úÖ Para aplicaciones web y m√≥viles con datos din√°micos y flexibles.

‚úÖ Si buscas escalabilidad horizontal para manejar alto tr√°fico.

‚úÖ Para Big Data, IoT y aplicaciones en tiempo real.


<br>
<br>

## üîπ ¬øCu√°ndo NO usar MongoDB?

‚ùå Si necesitas relaciones complejas entre datos (ej. ERP, banca).

‚ùå Cuando requieres transacciones ACID fuertes (ej. sistemas financieros).

‚ùå Si los datos son altamente estructurados y no cambian mucho.


<br>
<br>


## ¬øQu√© es lo que hemos hecho?
Esta es nuestra base de datos en MongoDB Atlas. A continuaci√≥n, os mostraremos las colecciones que contiene y os explicaremos la funci√≥n de cada una de ellas.

![image](https://github.com/user-attachments/assets/0be57b9c-2c76-4fc4-8aeb-04e71d1d4d93)


### Channels
En esta secci√≥n, almacenamos los canales disponibles en nuestra p√°gina web. Aqu√≠ podr√°s ver el nombre del canal, la fecha de creaci√≥n, si es p√∫blico o privado, su estado (activo o inactivo), qui√©n lo cre√≥ y los miembros que forman parte de √©l.

![image](https://github.com/user-attachments/assets/2151207c-312c-47e4-8aaa-de496b998349)


### Files
Aqu√≠ almacenamos los archivos enviados entre usuarios. Podr√°s ver en qu√© canal se envi√≥ el archivo, la hora de env√≠o y el tipo de archivo.

![image](https://github.com/user-attachments/assets/e2ef22cb-ca6b-412e-9a94-f1afa139f570)



### Messages
En esta secci√≥n se almacenan los mensajes enviados entre usuarios y en los canales. Tambi√©n se muestra la fecha en que se envi√≥ cada mensaje.

![image](https://github.com/user-attachments/assets/d6c36f84-5adf-4e20-9633-220c589c6e20)



### Private-Chats
En esta secci√≥n se encuentran los chats privados creados por los usuarios. Podr√°s ver los miembros de cada chat y los mensajes enviados en ellos.

![image](https://github.com/user-attachments/assets/4c1f7e9d-d832-43ed-bf88-e336d4bbcd4e)



### Users
Aqu√≠ almacenamos la informaci√≥n de los usuarios registrados en nuestra web. Puedes ver el nombre de usuario, correo electr√≥nico, contrase√±a, estado, fecha de creaci√≥n de la cuenta, √∫ltima conexi√≥n, amigos y los usuarios que ha bloqueado.

![image](https://github.com/user-attachments/assets/1700c6c9-b171-4909-bfc9-7e5d47ac572e)

![image](https://github.com/user-attachments/assets/3ab81af1-90b3-46a8-9389-d80e080309ae)



## Referencias que hemos consegido para crear la BBDD

Nuestro profesor Joaqu√≠n
Tutor√≠ales de Youtube:



<br>

<details>
  <summary>üîóüçÉ Como conectarte a la BBDD desde la Nube de MongoDB</summary>

Estos pasos son de priva para novatos para que se pueda entender mejor.

<br>



## Tener Node.js instalado. Si no lo tienes, puedes instalarlo ejecutando los siguientes comandos:

```
sudo apt update
sudo apt upgrade
sudo apt install nodejs
sudo apt install npm
```
<br>


## Upgrade Node.js

* Si tu versi√≥n es inferior a 14, necesitar√°s actualizar al menos a Node.js 14 o superior.

* Para Ubuntu, puedes usar nvm (Node Version Manager) para cambiar versiones f√°cilmente:

```
sudo apt install curl
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash
source ~/.bashrc
nvm install 14  # or higher
nvm use 14
```
<br>


## Alternative solution

* Podr√≠as intentar degradar tu controlador MongoDB/paquete mongoose a una versi√≥n que no utilice el operador de coalici√≥n nulo:


```
npm uninstall mongodb mongoose
npm install mongoose@5.11.15 mongodb@3.6.4
```
<br>



## Configuraci√≥n del Proyecto:

```
npm init -y
npm install express mongoose bcrypt cors
```
<br>


## Estructura de Archivos:

```
/proyecto
  /models
    User.js
  server.js
  /public
    index.html
    login.html
    dashboard.html
```


<br>

## Conexi√≥n con MongoDB (server.js):

```
const express = require('express');
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const cors = require('cors');
const app = express();

// Conexi√≥n a MongoDB Atlas
mongoose.connect('mongodb+srv://EGC:password1234@cluster0.kbtve.mongodb.net/EGC?retryWrites=true&w=majority', {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('Conectado a MongoDB Atlas'))
.catch(err => console.error(err));

app.use(express.json());
app.use(cors());
app.use(express.static('public'));

// Modelo User (models/User.js)
const userSchema = new mongoose.Schema({
  username: { type: String, unique: true },
  email: { type: String, unique: true },
  password_hash: String,
  status: String,
  created_at: Date,
  last_login: Date
});

const User = mongoose.model('User', userSchema);

// Rutas de autenticaci√≥n
app.post('/register', async (req, res) => {
  try {
    const hashedPassword = await bcrypt.hash(req.body.password, 10);
    const user = new User({
      username: req.body.username,
      email: req.body.email,
      password_hash: hashedPassword,
      status: 'offline',
      created_at: new Date()
    });
    await user.save();
    res.status(201).send('Usuario registrado');
  } catch (error) {
    res.status(500).send(error.message);
  }
});

app.post('/login', async (req, res) => {
  try {
    const user = await User.findOne({ username: req.body.username });
    if (!user) return res.status(400).send('Usuario no encontrado');
    
    const validPass = await bcrypt.compare(req.body.password, user.password_hash);
    if (!validPass) return res.status(400).send('Contrase√±a incorrecta');
    
    user.last_login = new Date();
    await user.save();
    res.send('Login exitoso');
  } catch (error) {
    res.status(500).send(error.message);
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Servidor en puerto ${PORT}`));
```


<br>

## Frontend (public/index.html - Registro):

```
<!DOCTYPE html>
<html>
<head>
    <title>Registro</title>
</head>
<body>
    <h2>Registro</h2>
    <form id="registerForm">
        <input type="text" id="username" placeholder="Usuario" required>
        <input type="email" id="email" placeholder="Email" required>
        <input type="password" id="password" placeholder="Contrase√±a" required>
        <button type="submit">Registrar</button>
    </form>

    <script>
        document.getElementById('registerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const response = await fetch('/register', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    username: document.getElementById('username').value,
                    email: document.getElementById('email').value,
                    password: document.getElementById('password').value
                })
            });
            
            const result = await response.text();
            alert(result);
        });
    </script>
</body>
</html>
```



<br>

## Frontend (public/login.html - Login):

```
<!DOCTYPE html>
<html>
<head>
    <title>Login</title>
</head>
<body>
    <h2>Login</h2>
    <form id="loginForm">
        <input type="text" id="username" placeholder="Usuario" required>
        <input type="password" id="password" placeholder="Contrase√±a" required>
        <button type="submit">Ingresar</button>
    </form>

    <script>
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const response = await fetch('/login', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    username: document.getElementById('username').value,
                    password: document.getElementById('password').value
                })
            });
            
            const result = await response.text();
            alert(result);
            if(response.ok) window.location.href = '/dashboard.html';
        });
    </script>
</body>
</html>
```



<br>

## Pasos para Ejecutar (Windows/Linux):


<br>

### Configura variables de entorno:

```
export MONGODB_URI='mongodb+srv://EGC:password1234@cluster0.kbtve.mongodb.net/EGC?retryWrites=true&w=majority'
```



<br>

### Inicia el servidor:

```
node server.js
```


<br>

### Accede desde tu navegador:

```
http://localhost:3000/index.html
http://localhost:3000/login.html
```



<br>

### Consideraciones de Seguridad:

1. Usa variables de entorno para credenciales (dotenv)

2. Implementa JWT para autenticaci√≥n

3. Agrega validaci√≥n de entrada

4. Usa HTTPS en producci√≥n

5. Limita intentos de login



<br>

### Para MongoDB Atlas:


1. Verifica la whitelist de IPs en Atlas

2. Mant√©n actualizados los drivers

3. Usa √≠ndices para consultas frecuentes

4. Implementa copias de seguridad regulares




  
</details>
<br>
<br>
<br>

  
</details>




<br>

<details>
  <summary>üåêüîóüí¨ WebSocket</summary>

# WebSocket

<br>

## ¬øQu√© es WebSocket?

WebSocket es un protocolo de comunicaci√≥n que proporciona un canal de comunicaci√≥n bidireccional y persistente entre el cliente (por ejemplo, un navegador web) y un servidor. A diferencia de los m√©todos tradicionales de comunicaci√≥n HTTP, donde cada solicitud del cliente al servidor crea una nueva conexi√≥n y debe cerrarse despu√©s de recibir la respuesta, WebSocket mantiene una conexi√≥n abierta, lo que permite que los datos se intercambien de manera continua sin necesidad de abrir nuevas conexiones.

![image](https://github.com/user-attachments/assets/02d4268b-ba83-4c6c-b205-21311c6c01ff)

<br>


## Caracter√≠sticas clave de WebSocket

1Ô∏è‚É£ Conexi√≥n persistente:

* ¬øQu√© significa? Una vez que se establece una conexi√≥n WebSocket entre el cliente y el servidor, esta se mantiene abierta durante todo el tiempo que sea necesario. No es como HTTP, que abre y cierra una conexi√≥n para cada solicitud. Esto mejora la eficiencia, ya que no es necesario realizar m√∫ltiples "handshakes" (intercambios de informaci√≥n para abrir y cerrar conexiones) constantemente.

* Beneficio: Permite que el servidor y el cliente se comuniquen continuamente sin la necesidad de establecer nuevas conexiones cada vez que haya algo que transmitir.


2Ô∏è‚É£ Comunicaci√≥n bidireccional:

* ¬øQu√© significa? Ambos lados de la conexi√≥n (el cliente y el servidor) pueden enviar y recibir datos en cualquier momento. Mientras que en HTTP el cliente generalmente hace solicitudes y espera respuestas del servidor, en WebSocket, tanto el servidor como el cliente pueden enviar mensajes sin que uno tenga que esperar al otro.

* Beneficio: Esto es especialmente √∫til para aplicaciones que requieren una comunicaci√≥n constante y sin interrupciones, como en chats o juegos en l√≠nea.


3Ô∏è‚É£ Baja latencia:

* ¬øQu√© significa? Dado que WebSocket mantiene una conexi√≥n abierta de manera persistente, los mensajes se pueden enviar y recibir sin la sobrecarga de establecer nuevas conexiones o esperar por respuestas del servidor. Esto reduce la latencia (el tiempo de espera entre enviar un mensaje y recibir una respuesta).

* Beneficio: Es ideal para aplicaciones en tiempo real donde los usuarios necesitan respuestas instant√°neas, como en aplicaciones de mensajer√≠a o en plataformas de trading financiero.


4Ô∏è‚É£ Protocolo basado en TCP:

* ¬øQu√© significa? WebSocket se construye sobre el protocolo de transmisi√≥n TCP (Transmission Control Protocol), que es un protocolo confiable. Esto significa que los datos se transmiten de manera ordenada y garantizada. Si alg√∫n paquete de datos se pierde, TCP se encarga de reintentarlo hasta que se reciba correctamente.

* Beneficio: Da confiabilidad a las comunicaciones, asegurando que los mensajes lleguen de manera correcta y en el orden adecuado.

<br>

## Casos de uso comunes

1Ô∏è‚É£ Aplicaciones en tiempo real:

* Ejemplos: Chats en vivo, mensajer√≠a instant√°nea, aplicaciones colaborativas.

* ¬øPor qu√© WebSocket? En estas aplicaciones, los usuarios esperan que los mensajes se reciban y se env√≠en de inmediato. Si se tuviera que abrir y cerrar una nueva conexi√≥n para cada mensaje, esto ser√≠a muy ineficiente. Con WebSocket, la conexi√≥n est√° siempre activa, permitiendo la transmisi√≥n instant√°nea de mensajes.


2Ô∏è‚É£ Juegos en l√≠nea:

* Ejemplos: Juegos multijugador, plataformas de juegos en tiempo real.

* ¬øPor qu√© WebSocket? Los juegos multijugador en l√≠nea requieren que el servidor y los jugadores se comuniquen constantemente para actualizar el estado del juego en tiempo real. Con WebSocket, los eventos del juego (como el movimiento de los personajes, la puntuaci√≥n, etc.) pueden ser enviados y recibidos de manera instant√°nea y continua sin la latencia de las solicitudes HTTP tradicionales.


3Ô∏è‚É£ Notificaciones en tiempo real:

* Ejemplos: Notificaciones de nuevos mensajes, alertas en aplicaciones, actualizaciones de noticias.

* ¬øPor qu√© WebSocket? Las notificaciones que se actualizan constantemente, como los avisos en una red social o las alertas de sistemas, requieren un intercambio de datos en tiempo real. WebSocket permite que el servidor "emita" las notificaciones directamente a los clientes conectados, sin que el cliente tenga que hacer una solicitud constante al servidor.


4Ô∏è‚É£ Plataformas de trading en l√≠nea:

* Ejemplos: Mercados de acciones, criptomonedas.

* ¬øPor qu√© WebSocket? En plataformas de trading, los precios de las acciones o las criptomonedas cambian r√°pidamente. Los traders necesitan informaci√≥n actualizada al instante para tomar decisiones informadas. WebSocket permite recibir actualizaciones de precios en tiempo real sin retrasos, lo que es crucial para una toma de decisiones √°gil.


5Ô∏è‚É£ Aplicaciones de colaboraci√≥n en tiempo real:

* Ejemplos: Google Docs, aplicaciones de edici√≥n compartida.

* ¬øPor qu√© WebSocket? Cuando varios usuarios est√°n colaborando en un mismo documento, los cambios deben ser reflejados en tiempo real para todos los participantes. WebSocket garantiza que los cambios de un usuario se env√≠en y reciban instant√°neamente, manteniendo todos los participantes sincronizados.

<br>
<br>
<br>

<details>
  <summary>+----------üå±üí¨ Lo basico</summary>

Para crear un **WebSocket** en un servidor Ubuntu Linux, generalmente se utiliza una tecnolog√≠a de servidor como Node.js, Python (con ```websockets``` o ```socket.io```), o incluso directamente en el servidor web (Apache, Nginx) con soporte para WebSocket. Aqu√≠ te voy a explicar c√≥mo crear un servidor WebSocket utilizando Node.js y el paquete ```ws```, que es uno de los m√©todos m√°s sencillos.

## Requisitos Previos

### 1. Tener un servidor Ubuntu Linux funcionando.

### 2. Tener Node.js instalado. Si no lo tienes, puedes instalarlo ejecutando los siguientes comandos:

```
sudo apt update
sudo apt upgrade
sudo apt install nodejs
sudo apt install npm
```

Para verificar que se instal√≥ correctamente:

```
node -v
npm -v
```

<br>

## Pasos para Crear un WebSocket con Node.js

### 1. Crea un directorio para tu proyecto.

```
mkdir websocket-server
cd websocket-server
```

### 2. Inicializa un nuevo proyecto Node.js.

```
npm init -y
```

Este comando generar√° un archivo ```package.json``` con la configuraci√≥n b√°sica de tu proyecto.


### 3. Instala el paquete ```ws```.

```ws``` es una librer√≠a simple y eficiente para trabajar con WebSockets en Node.js.

```
npm install ws
```

### 4. Crea un archivo de servidor WebSocket (por ejemplo, ```server.js```).

Crea el archivo ```server.js``` dentro de tu directorio de proyecto.

```
touch server.js
```

### 5. Escribe el c√≥digo para tu servidor WebSocket en server.js.

Abre server.js con tu editor de texto preferido (por ejemplo, nano, vim, o tu editor favorito). Escribe el siguiente c√≥digo:

```
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

// Mantener una lista de todos los clientes conectados
let clients = [];

wss.on('connection', (ws) => {
  console.log('Nuevo cliente conectado.');
  
  // Agregar el cliente a la lista
  clients.push(ws);

  // Enviar un mensaje de bienvenida al cliente
  ws.send('Bienvenido al servidor WebSocket. Ahora puedes chatear con otros usuarios.');

  // Escuchar mensajes enviados desde el cliente
  ws.on('message', (message) => {
    console.log(`Mensaje recibido: ${message}`);

    // Enviar el mensaje a todos los dem√°s clientes
    clients.forEach((client) => {
      if (client !== ws) {
        client.send(message);
      }
    });
  });

  // Manejar cierre de conexi√≥n
  ws.on('close', () => {
    console.log('Cliente desconectado');

    // Eliminar el cliente de la lista
    clients = clients.filter(client => client !== ws);
  });
});

console.log('Servidor WebSocket escuchando en ws://localhost:8080');
```

#### Explicaci√≥n:

* Lista de clientes: Creamos un array ```clients``` que almacenar√° todas las conexiones activas.
* Conexi√≥n y desconexi√≥n de clientes: Cuando un cliente se conecta, se agrega a esta lista. Cuando se desconecta, se elimina de la lista.
* Env√≠o de mensajes: Cuando un cliente env√≠a un mensaje, el servidor lo reenv√≠a a todos los dem√°s clientes en la lista (excepto al propio cliente que lo envi√≥).


### 6. Ejecuta el servidor WebSocket.

Una vez que hayas escrito el c√≥digo, guarda el archivo y ejecuta el servidor:

```
node server.js
```

El servidor ahora deber√≠a estar corriendo en ```ws://localhost:8080```.


### 7. Verifica que el servidor WebSocket est√° funcionando.

Abre un navegador web o usa una herramienta como Postman o un cliente WebSocket en JavaScript para conectarte al servidor. Si usas JavaScript en el navegador, puedes crear un cliente WebSocket simple de la siguiente manera:

En un archivo ```client.html```:

```
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cliente WebSocket</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }
    #messages {
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 20px;
      height: 200px;
      overflow-y: auto;
    }
    #inputMessage {
      width: 80%;
      padding: 10px;
    }
    #sendMessageButton {
      padding: 10px;
    }
  </style>
</head>
<body>
  <h1>Cliente WebSocket</h1>

  <div id="messages"></div>

  <input type="text" id="inputMessage" placeholder="Escribe tu mensaje...">
  <button id="sendMessageButton">Enviar mensaje</button>

  <script>
    // Conexi√≥n al servidor WebSocket
    const socket = new WebSocket('ws://localhost:8080');

    // Elementos de la p√°gina
    const messagesDiv = document.getElementById('messages');
    const inputMessage = document.getElementById('inputMessage');
    const sendMessageButton = document.getElementById('sendMessageButton');

    // Cuando se abre la conexi√≥n
    socket.onopen = function() {
      console.log('Conectado al servidor WebSocket');
    };

    // Cuando se recibe un mensaje del servidor
    socket.onmessage = function(event) {
      const message = event.data; // Esto es el mensaje recibido

      // Si el mensaje es un Blob (lo que indica que es binario), convertirlo a texto
      if (message instanceof Blob) {
        message.text().then(function(text) {
          console.log('Mensaje recibido del servidor: ' + text);

          // Mostrar el mensaje recibido en el div de mensajes
          const messageDiv = document.createElement('div');
          messageDiv.textContent = 'Otro usuario: ' + text;
          messagesDiv.appendChild(messageDiv);
          messagesDiv.scrollTop = messagesDiv.scrollHeight;
        });
      } else {
        // Si el mensaje ya es texto, simplemente mostrarlo
        console.log('Mensaje recibido del servidor: ' + message);

        // Mostrar el mensaje recibido en el div de mensajes
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'Otro usuario: ' + message;
        messagesDiv.appendChild(messageDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      }
    };

    // Cuando se cierra la conexi√≥n
    socket.onclose = function() {
      console.log('Desconectado del servidor WebSocket');
    };

    // Enviar mensaje al servidor cuando el usuario hace clic en el bot√≥n
    sendMessageButton.addEventListener('click', function() {
      const messageToSend = inputMessage.value;
      if (messageToSend) {
        // Enviar el mensaje al servidor WebSocket
        socket.send(messageToSend);

        // Mostrar el mensaje en la p√°gina como si fuera del cliente
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'T√∫: ' + messageToSend;
        messagesDiv.appendChild(messageDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;

        // Limpiar el campo de entrada
        inputMessage.value = '';
      }
    });

    // Opcional: Enviar el mensaje cuando presionas Enter
    inputMessage.addEventListener('keypress', function(event) {
      if (event.key === 'Enter') {
        sendMessageButton.click();
      }
    });
  </script>
</body>
</html>

```

#### Explicaci√≥n:

##### Detecci√≥n de tipo Blob:

* Al recibir un mensaje del servidor en el cliente, primero se verifica si el mensaje es de tipo Blob. Esto se hace con if (message instanceof Blob).

* Si el mensaje es un Blob, usamos el m√©todo .text() para convertirlo a texto antes de mostrarlo. El .text() devuelve una promesa que resuelve en el contenido del Blob como una cadena de texto.

* Si el mensaje no es un Blob, se considera que ya es texto y se muestra directamente.

##### Manejo de mensajes:

* Cuando el mensaje recibido es texto, se muestra como antes: en el div con id messages.

* Si el mensaje es un Blob, primero lo convertimos a texto y luego lo mostramos en el div.








</details>


<br>
<br>
<br>


<details>
  <summary>+----------üß†üåêüöÄ Avanzado</summary>
Para crear un **WebSocket** en un servidor Ubuntu Linux, generalmente se utiliza una tecnolog√≠a de servidor como Node.js, Python (con ```websockets``` o ```socket.io```), o incluso directamente en el servidor web (Apache, Nginx) con soporte para WebSocket. Aqu√≠ te voy a explicar c√≥mo crear un servidor WebSocket utilizando Node.js y el paquete ```ws```, que es uno de los m√©todos m√°s sencillos.

## Requisitos Previos

### 1. Tener un servidor Ubuntu Linux funcionando.

### 2. Tener Node.js instalado. Si no lo tienes, puedes instalarlo ejecutando los siguientes comandos:

```
sudo apt update
sudo apt upgrade
sudo apt install nodejs
sudo apt install npm
```

Para verificar que se instal√≥ correctamente:

```
node -v
npm -v
```

<br>

## Pasos para Crear un WebSocket con Node.js

### 1. Crea un directorio para tu proyecto.

```
mkdir websocket-server
cd websocket-server
```

### 2. Inicializa un nuevo proyecto Node.js.

```
npm init -y
```

Este comando generar√° un archivo ```package.json``` con la configuraci√≥n b√°sica de tu proyecto.


### 3. Instala el paquete ```ws```.

```ws``` es una librer√≠a simple y eficiente para trabajar con WebSockets en Node.js.

```
npm install ws
```

### 4. Crea un archivo de servidor WebSocket (por ejemplo, ```server.js```).

Crea el archivo ```server.js``` dentro de tu directorio de proyecto.

```
touch server.js
```

### 5. Escribe el c√≥digo para tu servidor WebSocket en server.js.

Abre server.js con tu editor de texto preferido (por ejemplo, nano, vim, o tu editor favorito). Escribe el siguiente c√≥digo:

```
const WebSocket = require('ws');

const wss = new WebSocket.Server({ port: 8080 });
let users = {};

wss.on("connection", (ws) => {
    ws.on("message", (message) => {
        const data = JSON.parse(message);

        switch (data.type) {
            case "register":
                users[data.userID] = ws;
                console.log(üìå Usuario registrado: ${data.userID});
                break;

            case "message":
                if (users[data.target]) {
                    users[data.target].send(JSON.stringify({ type: "message", from: data.from, text: data.text }));
                }
                break;

            case "offer":
            case "answer":
            case "candidate":
                if (users[data.target]) {
                    users[data.target].send(JSON.stringify(data));
                }
                break;

            default:
                console.log("üî¥ Tipo de mensaje desconocido:", data);
        }
    });

    ws.on("close", () => {
        Object.keys(users).forEach(userID => {
            if (users[userID] === ws) {
                delete users[userID];
                console.log(‚ùå Usuario desconectado: ${userID});
            }
        });
    });
});

console.log("‚úÖ Servidor WebSocket corriendo en ws://localhost:8080");
```

#### Explicaci√≥n:

* Lista de clientes: Creamos un array ```clients``` que almacenar√° todas las conexiones activas.
* Conexi√≥n y desconexi√≥n de clientes: Cuando un cliente se conecta, se agrega a esta lista. Cuando se desconecta, se elimina de la lista.
* Env√≠o de mensajes: Cuando un cliente env√≠a un mensaje, el servidor lo reenv√≠a a todos los dem√°s clientes en la lista (excepto al propio cliente que lo envi√≥).


### 6. Ejecuta el servidor WebSocket.

Una vez que hayas escrito el c√≥digo, guarda el archivo y ejecuta el servidor:

```
node server.js
```

El servidor ahora deber√≠a estar corriendo en ```ws://localhost:8080```.


### 7. Verifica que el servidor WebSocket est√° funcionando.

Abre un navegador web o usa una herramienta como Postman o un cliente WebSocket en JavaScript para conectarte al servidor. Si usas JavaScript en el navegador, puedes crear un cliente WebSocket simple de la siguiente manera:

En un archivo ```client.html```:

```
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat y Llamadas de Voz</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #messages { border: 1px solid #ccc; height: 200px; overflow-y: auto; padding: 10px; }
        #inputMessage { width: 80%; padding: 5px; }
        #sendMessageButton { padding: 5px; }
    </style>
</head>
<body>
    <h1>Chat y Llamadas de Voz</h1>

    <label>Tu ID de usuario:</label>
    <input type="text" id="userID" placeholder="Ingresa tu ID" required>
    <button id="register">Registrar</button>

    <label>Destinatario:</label>
    <input type="text" id="targetID" placeholder="ID del usuario a llamar">

    <div id="messages"></div>
    <input type="text" id="inputMessage" placeholder="Escribe un mensaje...">
    <button id="sendMessageButton">Enviar</button>

    <button id="startCall">Iniciar Llamada</button>
    <button id="hangUp">Colgar</button>

    <audio id="remoteAudio" autoplay></audio>

    <script>
        const socket = new WebSocket("ws://localhost:8080");
        let localStream;
        let peerConnection;
        let userID = null;

        const config = {
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" }, // Servidor STUN
                // Agregar un servidor TURN si es necesario
                { urls: "turn:turn.example.com", username: "user", credential: "password" }
            ],
            iceTransportPolicy: "all",  // Asegura que todos los candidatos ICE sean considerados
            optional: [
                { googEchoCancellation: true },  // Echo cancellation
                { googNoiseSuppression: true },  // Noise suppression
                { googHighpassFilter: true }     // High-pass filter for better sound quality
            ]
        };

        document.getElementById("register").addEventListener("click", () => {
            userID = document.getElementById("userID").value.trim();
            if (userID) {
                socket.send(JSON.stringify({ type: "register", userID }));
                alert(Registrado con ID: ${userID});
            }
        });

        socket.onmessage = async (event) => {
            const data = JSON.parse(event.data);

            if (data.type === "message") {
                displayMessage(${data.from}: ${data.text});
            } else if (data.type === "offer") {
                alert(üìû Llamada entrante de ${data.from});
                await createAnswer(data.offer, data.from);
            } else if (data.type === "answer") {
                peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
            } else if (data.type === "candidate") {
                peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
        };

        document.getElementById("sendMessageButton").addEventListener("click", () => {
            const messageInput = document.getElementById("inputMessage");
            const text = messageInput.value.trim();
            const target = document.getElementById("targetID").value.trim();
            if (text && target) {
                socket.send(JSON.stringify({ type: "message", from: userID, target, text }));
                displayMessage(T√∫: ${text});
                messageInput.value = "";
            }
        });

        function displayMessage(message) {
            const messagesDiv = document.getElementById("messages");
            const messageDiv = document.createElement("div");
            messageDiv.textContent = message;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        document.getElementById("startCall").addEventListener("click", async () => {
            const targetID = document.getElementById("targetID").value.trim();
            if (!targetID) {
                alert("Debes ingresar el ID del usuario al que deseas llamar.");
                return;
            }
            await startCall(targetID);
        });

        document.getElementById("hangUp").addEventListener("click", () => {
            hangUp();
        });

        async function startCall(target) {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

                peerConnection = new RTCPeerConnection(config);
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.send(JSON.stringify({ type: "candidate", candidate: event.candidate, target }));
                    }
                };

                peerConnection.ontrack = (event) => {
                    const remoteAudio = document.getElementById("remoteAudio");
                    if (remoteAudio.srcObject !== event.streams[0]) {
                        remoteAudio.srcObject = event.streams[0];
                    }
                };

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                socket.send(JSON.stringify({ type: "offer", offer, target, from: userID }));
            } catch (error) {
                console.error("Error en startCall:", error);
            }
        }

        async function createAnswer(offer, from) {
            try {
                peerConnection = new RTCPeerConnection(config);
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.send(JSON.stringify({ type: "candidate", candidate: event.candidate, target: from }));
                    }
                };

                peerConnection.ontrack = (event) => {
                    const remoteAudio = document.getElementById("remoteAudio");
                    if (remoteAudio.srcObject !== event.streams[0]) {
                        remoteAudio.srcObject = event.streams[0];
                    }
                };

                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                socket.send(JSON.stringify({ type: "answer", answer, target: from }));
            } catch (error) {
                console.error("Error en createAnswer:", error);
            }
        }

        function hangUp() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
        }

        peerConnection.oniceconnectionstatechange = (event) => {
            if (peerConnection.iceConnectionState === "failed") {
                alert("La conexi√≥n de la llamada ha fallado. Intentando reconectar...");
                hangUp();
                startCall(targetID);  // Intentar reconectar autom√°ticamente
            }
        };

        peerConnection.onerror = (event) => {
            console.error("Error en la conexi√≥n WebRTC:", event);
        };
    </script>
</body>
</html>

```

#### Explicaci√≥n:

##### Detecci√≥n de tipo Blob:

* Al recibir un mensaje del servidor en el cliente, primero se verifica si el mensaje es de tipo Blob. Esto se hace con if (message instanceof Blob).

* Si el mensaje es un Blob, usamos el m√©todo .text() para convertirlo a texto antes de mostrarlo. El .text() devuelve una promesa que resuelve en el contenido del Blob como una cadena de texto.

* Si el mensaje no es un Blob, se considera que ya es texto y se muestra directamente.

##### Manejo de mensajes:

* Cuando el mensaje recibido es texto, se muestra como antes: en el div con id messages.

* Si el mensaje es un Blob, primero lo convertimos a texto y luego lo mostramos en el div.










</details>









</details>

<br>

<details>
  <summary>üñ•Ô∏èüåêüíª Servidor Web</summary>

# ¬øQu√© es un Servidor de Web?

Un servidor web es un software o sistema que se encarga de recibir, procesar y responder a las solicitudes que los navegadores web (o cualquier cliente HTTP) env√≠an para acceder a los recursos alojados en un sitio web. Los recursos m√°s comunes que maneja un servidor web son las p√°ginas web, que generalmente est√°n escritas en HTML, pero tambi√©n puede servir otros tipos de contenido como im√°genes, videos, archivos CSS, JavaScript y m√°s.

Cuando un usuario ingresa una direcci√≥n web (URL) en su navegador, el navegador env√≠a una solicitud HTTP al servidor web correspondiente. El servidor web luego procesa esa solicitud, recupera el archivo solicitado (por ejemplo, una p√°gina HTML) y lo env√≠a de vuelta al navegador para que se muestre al usuario.

![image](https://github.com/user-attachments/assets/1e220d5f-dd4c-4ba5-969a-c6fc51c6eb69)

<br>

Los pasos b√°sicos de funcionamiento de un servidor web son:

* Recepci√≥n de la solicitud: El navegador realiza una solicitud HTTP al servidor web, generalmente solicitando un archivo o recurso espec√≠fico.

* Procesamiento de la solicitud: El servidor verifica la solicitud y, si es v√°lida, busca el recurso solicitado (por ejemplo, una p√°gina HTML).

* Env√≠o de la respuesta: Una vez que el recurso ha sido encontrado, el servidor web env√≠a el archivo al navegador del usuario, que lo muestra en la pantalla.

Algunos ejemplos populares de servidores web son:

* Apache HTTP Server: Muy popular y ampliamente utilizado en entornos Linux.

* Nginx: Conocido por su alto rendimiento y eficiencia.

* Microsoft IIS: Utilizado principalmente en entornos Windows.

<br>
<br>
<br>

# ¬øQu√© es un NGINX?

NGINX es un servidor web de alto rendimiento, servidor proxy inverso y balanceador de carga muy utilizado en la infraestructura de Internet. Fue creado originalmente para ser un servidor web, pero con el tiempo ha evolucionado para ofrecer m√∫ltiples funcionalidades adicionales. Su principal ventaja es su capacidad para manejar un gran volumen de conexiones concurrentes de manera eficiente y con un bajo uso de recursos.

![Comandos-de-Nginx-que-usted-debe-saber-removebg-preview](https://github.com/user-attachments/assets/72dd8064-c11a-4840-92f3-c7218227b21c)

<br>

Algunas de las funciones m√°s destacadas de NGINX incluyen:

* Servidor web: Sirve contenido est√°tico (como archivos HTML, im√°genes, videos) a los usuarios.

* Proxy inverso: Redirige las solicitudes de los usuarios a otros servidores (por ejemplo, servidores de aplicaciones), mejorando la seguridad y la carga de trabajo distribuida.

* Balanceador de carga: Distribuye el tr√°fico de red entre varios servidores para asegurar que ninguno de ellos se sobrecargue, mejorando la disponibilidad y la fiabilidad del sistema.

* Cacheo: Guarda en memoria las respuestas de servidores backend para reducir la carga y acelerar las respuestas a los usuarios.

  NGINX es conocido por su alta eficiencia y su capacidad para manejar miles de conexiones simult√°neas con un uso m√≠nimo de recursos, lo que lo convierte en una opci√≥n popular para aplicaciones web de alto tr√°fico.

  Es muy com√∫n encontrarlo en la infraestructura de empresas que gestionan aplicaciones web de gran escala.

<br>
<br>
<br>

# Los pasos para crear el Servidor Web con NGINX

## Paso 1: Actualizar los paquetes del sistema
Antes de instalar NGINX, es recomendable actualizar la lista de paquetes disponibles y los paquetes del sistema para asegurarse de que estamos trabajando con versiones recientes.
```
sudo apt update
sudo apt upgrade -y

```

## Paso 2: Instalar NGINX

Una vez actualizado el sistema, se puede instalar NGINX utilizando el gestor de paquetes apt:

```
sudo apt install nginx -y
```

## Paso 3: Verificar la instalaci√≥n de NGINX
Una vez que la instalaci√≥n haya finalizado, puedes verificar que NGINX se haya instalado correctamente ejecutando:

```
nginx -v
```



</details>

<br>

<details>
  <summary>üñ•Ô∏èüåêüîÑ Servidor DNS</summary>

Un servidor DNS (Domain Name System) es un sistema que traduce los nombres de dominio (como www.ejemplo.com) en direcciones IP (como 192.168.1.1) que las computadoras usan para identificarse y comunicarse en una red, como Internet.

![image](https://github.com/user-attachments/assets/f216feb9-9c30-4a78-bf23-e86f54922e99)

<br>

Cuando escribes una direcci√≥n web en tu navegador, el servidor DNS se encarga de buscar la direcci√≥n IP correspondiente a ese nombre de dominio para que puedas acceder al sitio web. Esto es necesario porque las computadoras y otros dispositivos en una red se identifican mediante direcciones IP, pero para los usuarios es mucho m√°s f√°cil recordar nombres de dominio que n√∫meros de IP.

En resumen, el servidor DNS act√∫a como una especie de "agenda telef√≥nica" de Internet, ayudando a resolver los nombres de dominio en las direcciones num√©ricas necesarias para acceder a los recursos en l√≠nea.



</details>


<br>

<details>
  <summary>‚úâÔ∏è Servidor Correo</summary>

# Servidor Correo

Un servidor de correo es un sistema que gestiona y distribuye los correos electr√≥nicos entre los usuarios. Su funci√≥n principal es recibir, almacenar y enviar mensajes de correo electr√≥nico. Los servidores de correo se encargan de facilitar la comunicaci√≥n a trav√©s del correo electr√≥nico en redes locales o en Internet.

![imagen_2025-03-17_170139970-removebg-preview](https://github.com/user-attachments/assets/a2bbb248-9043-45a1-9ec1-26706097fff0)

<br>

Existen diferentes tipos de servidores de correo, como:

## 1. Servidor de correo entrante (IMAP/POP3)
Se encarga de recibir y almacenar los correos en una bandeja de entrada. El usuario puede acceder a sus mensajes a trav√©s de un cliente de correo, como Outlook, Thunderbird, o aplicaciones m√≥viles. IMAP (Internet Message Access Protocol) mantiene los mensajes en el servidor, mientras que POP3 (Post Office Protocol) descarga los correos al dispositivo y los elimina del servidor.


## 2. Servidor de correo saliente (SMTP)
Es el responsable de enviar los correos electr√≥nicos a otros servidores o destinatarios. SMTP (Simple Mail Transfer Protocol) es el protocolo utilizado para enviar los mensajes.





</details>



<br>



<details>
  <summary>üåêüó®Ô∏èüë•Codigo de la P√°gina Web-Chat</summary>


  # Las tecnolog√≠as que se utilizan en la p√°gina Web.

  
  ## üåê Core del Backend
  
  * Node.js üü©
  
  Motor de ejecuci√≥n JavaScript del lado del servidor. Hace posible que tu aplicaci√≥n corra fuera del navegador.
  
  * Express üü¶
  
  Framework web minimalista. Maneja las rutas HTTP (GET/POST), middlewares y la API REST.
  
  * Mongoose üçÉ
  
  ODM (Mapeo Objeto-Documento) para MongoDB. Modela tus datos (usuarios, mensajes) y valida esquemas.


  <br>


  ## üóÉÔ∏è Base de Datos
  
  * MongoDB Atlas ‚òÅÔ∏è
  
  Base de datos NoSQL en la nube. Almacena usuarios, chats, grupos y mensajes en formato JSON (BSON).


  <br>


  ## üé® Frontend
  
  * HTML5 üèóÔ∏è
    
  Estructura √≥sea de tu aplicaci√≥n (formularios, contenedores de chat).
  
  * CSS3 üé®
  
  Estilos visuales (colores, dise√±os responsive, animaciones).
  
  * JavaScript Vanilla ‚ö°
  
  L√≥gica del cliente: manejo de eventos, interacci√≥n con WebSockets y DOM.


  <br>

  
  ## üîå Comunicaci√≥n en Tiempo Real
  * WebSocket (ws) üì°
  
  Protocolo para conexiones persistentes bidireccionales. Notifica mensajes nuevos sin refrescar la p√°gina.
  
  * WebRTC üìπ
 
  Permite llamadas de voz/video P2P (usado en tu m√≥dulo de videollamadas).


  <br>

  
  ## üîê Seguridad
  * Bcrypt üîí
    
  Encripta contrase√±as antes de guardarlas en la BD (protecci√≥n contra filtraciones).
  
  * JWT ü™ô
  
  Tokens de autenticaci√≥n sin estado. Verifica la identidad del usuario en cada petici√≥n.
  
  * Web Crypto API üõ°Ô∏è
  
  API nativa del navegador para el cifrado E2EE (RSA-OAEP en tu caso).


  <br>


  ## ‚öôÔ∏è Utilidades
  
  * Dotenv üìù
  
  Carga variables de entorno (.env) como claves secretas y configuraciones.
  
  * CORS ‚ÜîÔ∏è
  
  Permite comunicaci√≥n segura entre frontend y backend cuando est√°n en dominios diferentes.
  
  * Nodemon üëπ
  
  Reinicia autom√°ticamente el servidor cuando detecta cambios (solo para desarrollo).



  <br>
  <br>
  <br>

  # Ruta del codigo:

  https://github.com/Trinidad666/EGC/tree/main/Web/Codigo-Web 


  <br>
  <br>
  <br>

  # üõ†Ô∏è Flujo de Trabajo

  ![deepseek_mermaid_20250505_11f74f](https://github.com/user-attachments/assets/2218fb49-07b8-48ea-9814-df3e9e343a6d)


  
</details>



