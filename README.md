# Intoducci√≥n

<details>
  <summary>üöÄ Explicaci√≥n de EGC</summary>
Nuestra empresa, EGC (Enterprise Global Chat), ofrece un servicio de chat especializado en diversos sectores como inform√°tica, negocios, econom√≠a, entre otros. Los usuarios registrados pueden consultar sus dudas directamente con expertos. Nuestro objetivo es brindar soluciones r√°pidas y efectivas, tanto para usuarios individuales como para peque√±as empresas.
<br>
<br>
  
Nuestra plataforma compite con otras herramientas de mensajer√≠a, como Telegram, Skype, Discord, y m√°s, especialmente en lo que respecta a la creaci√≥n de grupos y redes de usuarios. Sin embargo, en nuestra plataforma, todos los chats son privados entre los usuarios conectados, permitiendo conversaciones directas y seguras.
<br>

Al registrarse en nuestra web, los usuarios podr√°n acceder a grupos creados por especialistas en sectores como inform√°tica, negocios, econom√≠a y otros, disponibles en modalidades p√∫blicas o privadas. Adem√°s, los usuarios podr√°n crear sus propios grupos de conversaci√≥n para compartir informaci√≥n y resolver dudas con otros usuarios.
  
</details>
<br>








<details>
<summary>üé® Dise√±o de nuestra aplicaci√≥n</summary>


## Mockup

### Home

* En la p√°gina de inicio tendr√≠amos una imagen de fondo, y en la parte superior de la pesta√±a se mostrar√≠a el logo junto a tres enlaces que dirigir√≠an a p√°ginas donde hablar√≠amos sobre nosotros, nuestra seguridad y soporte t√©cnico, as√≠ como al inicio de sesi√≥n. Adem√°s, contar√≠amos con un footer que incluir√≠a los logotipos de nuestras redes sociales.

![image](https://github.com/user-attachments/assets/7c5c27db-fa5a-4ce7-b655-c1a179c5a935)


### Sobre Nosotros

* En la secci√≥n "Sobre nosotros", os explicaremos qu√© hace nuestra empresa, cu√°ndo fue creada y qu√© ventajas ofrece en comparaci√≥n con otros servicios de chat. Tambi√©n incluir√≠amos im√°genes decorativas para mejorar la presentaci√≥n.

![image](https://github.com/user-attachments/assets/4367be43-9c0b-4f62-b6b4-724a5508d5c5)


### Nuestra Seguridad

* En la secci√≥n "Nuestra seguridad" explicaremos las medidas de seguridad que ofrecemos, sin entrar en detalles espec√≠ficos.

![image](https://github.com/user-attachments/assets/941276f0-4848-47e5-897f-c80d1c07cc01)


### Soporte T√©cnico

* En la secci√≥n de soporte t√©cnico, los usuarios podr√≠an ingresar su correo electr√≥nico, describir el problema que tienen y hacer clic en un bot√≥n de "Enviar".

![image](https://github.com/user-attachments/assets/63f4c1c3-9c71-42d7-8b81-6e513d4a79f4)


### Chat

* Este ser√≠a nuestro chat, con una lista a la izquierda que muestra nuestros contactos y amigos, y un buscador para encontrar a otros contactos.

![image](https://github.com/user-attachments/assets/6d88b906-7cba-4fa5-85a2-c13a1306e03a)


### Grupos

* En el cat√°logo, el usuario podr√° buscar temarios sobre ciberseguridad utilizando el buscador, y se le mostrar√°n diferentes temarios relacionados con el tema.

![image](https://github.com/user-attachments/assets/e68bcc31-368f-4f8c-a04e-0e3e9245ff63)


### Crear Grupo

* En "Crear cat√°logo", el usuario podr√° subir una imagen, a√±adir un t√≠tulo y un texto, y deber√° ingresar su nombre de usuario en un apartado. Al final, tendr√° un bot√≥n para crear el cat√°logo.

![image](https://github.com/user-attachments/assets/12724ed0-f878-4d0b-bd73-a0c204ee2e36)

### Registro

* As√≠ es como se ver√≠a la secci√≥n donde se registrar√≠an nuestros usuarios. En el formulario de registro, el usuario deber√° ingresar su nombre, primer apellido, un nombre de usuario, su correo electr√≥nico, n√∫mero de tel√©fono y una contrase√±a, la cual deber√° confirmar nuevamente.

![image](https://github.com/user-attachments/assets/587a3bd2-9e8c-4737-8d00-9a2e71e7e9d7)


### Inicio Sesi√≥n

* As√≠ es como se ver√≠a nuestro inicio de sesi√≥n. El usuario solo deber√° ingresar su correo electr√≥nico y contrase√±a.

![image](https://github.com/user-attachments/assets/37ec7c4c-e221-415c-9b8d-cca2adff63e8)

<br>

## Gamma de colores + Logo

### Nuestra gamma de colores

![image](https://github.com/user-attachments/assets/c999e1eb-701f-43bd-8a99-e5fd0f23e867)

### Nuestro Logo

![ECS](https://github.com/user-attachments/assets/6ba6de8e-952c-4265-9db4-ab254b4884f4)![image](https://github.com/user-attachments/assets/03bae469-1db6-44f0-bc5f-c439e731b600)


</details>
<br>










<details>
<summary>üó∫Ô∏è Nuestros esquemas</summary>
Este es nuestro esquema de nuestra web EGC:

![image](https://github.com/user-attachments/assets/d29a31b2-477b-47cb-b0c9-4ed494235236)


</details>
<br>


<details>
<summary>üìä Nuestros Diagramas</summary>

## Diagrama de RED
Como podemos ver en nuestro esquema de red, las m√°quinas de nuestro Proxmox se conectan al switch (vmbr0), que a su vez se conecta al router de IFP, proporcion√°ndonos la conexi√≥n a Internet. Ahora, os mostraremos las m√°quinas virtuales que contiene nuestro **Proxmox**:

1. Contamos con una m√°quina virtual (MV) que act√∫a como router y se conecta a trav√©s de **pfSense**, que funciona como el firewall de nuestro proyecto.
2. Tenemos una con el **DNS**.
3. Tenemos una MV donde almacenaremos la **WEB** y el **NGINX**.
4. Una con la bas de datos de **MongoDB**.
5. Contamos con una a la que hemos llamado **cliente** que utilizamos como prueba para verificar si nuestra web funciona correctamente.
6. Otra que contiene nuestro **Docker**.
7. Nuestro **servidor de correo**.
8. Contamos con una MV donde se almacenar√°n nuestros **backups** de **copias de seguridad** y **recuperaci√≥n**.

![Esquema-Red-Visual-Paradigm](https://github.com/user-attachments/assets/0e365779-b6c6-4654-9f4b-aa757ba3182c)


## Diagrama de BBDD
Como podemos ver en nuestro diagrama, la tabla **users** se conecta a la tabla **channels** utilizando las tablas de relaci√≥n **file** y **messages**. Tambi√©n, la tabla usuarios tiene, en conexi√≥n aparte, la tabla **friends** y la de **private_chat**.
Tambi√©n tenemos dos tablas de bloqueos, unas es para **Friends** y otra la usariamos en **Channels**.

Como podemos ver en nuestro diagrama, la tabla **users** se conecta a la tabla channels mediante las tablas de relaci√≥n **file** y **messages**. Adem√°s, la tabla users tiene, en una conexi√≥n aparte, la tabla **friends** y la de **private_chat**. Tambi√©n contamos con dos tablas de bloqueos: una es **block_friends**, que se utiliza para bloquear a amigos, y la otra es **block_channels**, que se usa para bloquear canales.


![image](https://github.com/user-attachments/assets/3c5e8c62-6a0e-470c-ba1f-e95a000f59e4)





</details>
<br>





<details>
<summary>üêã Docker</summary>

# ¬øQue es el Docker?

Docker es una plataforma que permite crear, distribuir y ejecutar aplicaciones en contenedores. Un contenedor es un entorno ligero y port√°til que incluye todo lo necesario para ejecutar un software, como c√≥digo, bibliotecas y dependencias, asegurando que funcione igual en cualquier sistema. Docker facilita la gesti√≥n y escalabilidad de aplicaciones, optimizando el uso de recursos y mejorando la eficiencia en desarrollo y despliegue. Se basa en im√°genes preconfiguradas y permite automatizar procesos, haci√©ndolo ideal para entornos de desarrollo, pruebas y producci√≥n en la nube o servidores locales.

![image](https://github.com/user-attachments/assets/538841f9-274d-48d4-9fd9-04ec71d46ebc)




# ¬øQu√© ventajas y desventajas ofrece Docker?


## Ventajas‚úÖ

¬∑ **Portabilidad de contenedores**: Los contenedores funcionan igual en cualquier sistema con Docker instalado.

¬∑ **Eficiencia**: Consume menos recursos que las m√°quinas virtuales porque comparte el sistema operativo.

¬∑ **Escalabilidad**: Facilita la gesti√≥n y despliegue de m√∫ltiples instancias de aplicaciones.

¬∑ **R√°pido despliegue**: Permite automatizar e implementar aplicaciones en segundos.

¬∑ **Aislamiento**: Evita conflictos entre dependencias de diferentes aplicaciones.



## Desventajas‚ùå

¬∑ **Rendimiento**: Puede ser menos eficiente que una ejecuci√≥n nativa.

¬∑ **Persistencia de datos**: Manejo de almacenamiento m√°s complejo.

¬∑ **Seguridad**: Comparte el kernel del host, lo que puede generar vulnerabilidades.



  
# Introducci√≥n a la instalaci√≥n de la web

Guardamos el contenido de la p√°gina web en una carpeta llamada web y la comprimimos en un archivo zip. Luego, la exportaremos a la m√°quina Alpine desde cmd utilizando el siguiente comando:

![image](https://github.com/user-attachments/assets/12bb95df-3edd-4466-9dd6-deb9006288c3)


Para descomprimir la carpeta que hemos exportado, utilizaremos el comando unzip. Luego, creamos una carpeta llamada **rbooks** donde almacenaremos la carpeta web que hemos descomprimido. Ser√° necesario mover la carpeta web dentro de la carpeta **rbooks**.


Accedemos a la carpeta **rbooks** y creamos las siguientes subcarpetas que mostraremos a continuaci√≥n:

![image](https://github.com/user-attachments/assets/8321eee2-4f73-4e67-9cb4-78866dbcaa43)


Dentro de la carpeta **nginx**, creamos un archivo llamado **default.conf** y le a√±adimos el siguiente c√≥digo:

![image](https://github.com/user-attachments/assets/90ee82b1-20dc-441f-b3be-433fbe1ac5a4)


Una vez hecho esto, salimos de la carpeta **nginx** y, dentro de **rbooks**, creamos un nuevo archivo llamado **docker-compose.yml**. A continuaci√≥n, en el archivo **docker-compose.yml**, aseguramos que el servicio **phpfpm** utilice el *Dockerfile* para construir la imagen personalizada. En lugar de usar la imagen **php:8-fpm-alpine** directamente, debemos indicar que se debe construir la imagen utilizando el *Dockerfile*.

```
services:
  # PHP service
  phpfpm:
    build:
      context: .
      dockerfile: Dockerfile   # Usa el Dockerfile personalizado
    container_name: phpfpm
    working_dir: /var/www/rbooks
    ports:
      - "9000:9000"
    volumes:
      - './web:/var/www/rbooks'
    environment:
      PHP_INI_DIR: /usr/local/etc/php
    restart: always
    networks:
      - netweb

  # Nginx service
  nginx:
    image: nginx:alpine
    container_name: nginx
    ports:
      - "8082:80"
    working_dir: /etc/nginx
    volumes:
      - './web:/var/www/rbooks'
      - './nginx/default.conf:/etc/nginx/conf.d/default.conf'
      - './nginx/:/var/log/nginx/'
    restart: always
    networks:
      - netweb

  # MySQL database service
  db:
    image: mysql
    container_name: miDB
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: 1234
    volumes:
      - './mysql:/var/lib/mysql'
      - './sql:/db'
    networks:
      - netweb

  # PHPMYADMIN
  phpmyadmin:
    image: phpmyadmin
    container_name: miphpmyadmin
    environment:
      PMA_ARBITRARY: 1
      PMA_HOST: db  # Conectar phpMyAdmin al contenedor "db" (MySQL)
    ports:
      - "81:80"
    networks:
      - netweb

networks:
  netweb:
    driver: bridge

```


A continuaci√≥n, crearemos el archivo **Dockerfile** y a√±adiremos el siguiente c√≥digo para que funcione:

![image](https://github.com/user-attachments/assets/fdf3e8b4-c8e5-4f59-8688-1e79b32abbb1)


Este comando permite forzar la recreaci√≥n de los contenedores en el **docker**.

![image](https://github.com/user-attachments/assets/152d72fb-a268-4556-888d-92b322e7e909)


Si accedemos a **Portainer** y vamos a la secci√≥n de **Contenedores**, podemos ver que se ha creado de forma correcta.

![image](https://github.com/user-attachments/assets/8b4ad89a-204d-4f24-87a1-d69f03bb1b1a)








Si accedemos al navegador y ponemos **http://100.77.20.22:8082**, podremos ver que hemos ingresado correctamente a la p√°gina web de RBooks.

![image](https://github.com/user-attachments/assets/574a6d8b-f4c5-4d1b-94d8-e1fc120731d3)


Ahora, debemos cargar la base de datos en **phpMyAdmin** para que las tablas se muestren correctamente y los registros funcionen en la p√°gina web. Para ello, accedemos a **http://100.77.20.22:81** en el navegador.
* Servidor --> miDB
* Usuario --> root
* Contrase√±a --> 1234
 
![image](https://github.com/user-attachments/assets/c53a9069-f0ab-4231-a811-68cecc4c103c)


Creamos la base de datos con el nombre **rbooks**.

![image](https://github.com/user-attachments/assets/04b92b6c-414e-4112-bf8d-d7967d416278)


Para poder importar el archivo **sql** en **phpMyAdmin**, debemos ingresar en la base de datos **rbooks**, hacer clic en *Importar*, seleccionar el archivo **bbdd-rbooks.sql** y luego hacer clic en el bot√≥n *Importar*.

![image](https://github.com/user-attachments/assets/2c2f841b-84cb-4e38-a4b2-d93207c67853)


A continuaci√≥n, accedemos al archivo **conexion_be.php**, que se encuentra en la ruta ***web/php_in-sing/conexion_be.php***, y modificamos la direcci√≥n de la base de datos para establecer la conexi√≥n entre la p√°gina web y la base de datos.

![image](https://github.com/user-attachments/assets/89863329-095d-4ba2-a6ff-69adf2947224)

<br>
<br>
<br>

# Las mejoras que hemos a√±adido

Estos son los comandos que le hemos puesto en el archivo **docker-compose.yml**.

<br>
<br>

## context: .

‚Ä¢	Define el directorio base donde Docker buscar√° los archivos necesarios para construir la imagen.

‚Ä¢	En este caso, el **.** (punto) indica que el contexto de construcci√≥n es el directorio donde se encuentra el archivo docker-compose.yml.


## dockerfile: Dockerfile

‚Ä¢	Indica al Docker qu√© archivo usar para construir la imagen. En este caso, se usar√° el Dockerfile que est√° en el contexto definido arriba (.).

‚Ä¢	Permite personalizar la imagen en lugar de usar una predefinida.



## PHP_INI_DIR: /usr/local/etc/php

Define la variable de entorno PHP_INI_DIR, que indica la ubicaci√≥n del archivo de configuraci√≥n de PHP (php.ini) dentro del contenedor.

<br>
<br>

## Dockerfile Vs docker-compose
![image](https://github.com/user-attachments/assets/7dbc6d20-f0fb-4d98-9a43-3b748478d106)



## Dockerfile

### 1Ô∏è‚É£ FROM php:8-fpm-alpine

```
FROM php:8-fpm-alpine
```

Define la imagen base como php:8-fpm-alpine.



### 2Ô∏è‚É£ Instalaci√≥n de dependencias y extensiones

```
RUN apk add --no-cache libpng-dev libjpeg-turbo-dev libwebp-dev \
    && docker-php-ext-install mysqli pdo pdo_mysql
```

Usa apk add --no-cache para instalar dependencias en Alpine Linux:

‚Ä¢	libpng-dev, libjpeg-turbo-dev, libwebp-dev: Bibliotecas necesarias para manipulaci√≥n de im√°genes en PHP.


Luego, instala extensiones de PHP con docker-php-ext-install:

‚Ä¢	mysqli: Extensi√≥n para conectarse a bases de datos MySQL.

‚Ä¢	pdo y pdo_mysql: Permiten usar PDO (PHP Data Objects) con MySQL.




### 3Ô∏è‚É£ (Opcional) Ajustar php.ini para habilitar mysqli

```
# RUN echo "extension=mysqli.so" >> /usr/local/etc/php/conf.d/docker-php-ext-mysqli.ini
```

Agrega manualmente la l√≠nea **extension=mysqli.so** al archivo de configuraci√≥n de PHP. Se usar√° cuando PHP no detecta autom√°ticamente la extensi√≥n mysqli.


üîπ ¬øCu√°ndo usarlo?

Si mysqli no se activa correctamente despu√©s de instalarlo con docker-php-ext-install para asegurar de que PHP cargue la extensi√≥n en cada inicio.







</details>
<br>








<details>
<summary>‚öôÔ∏è Funcionalidades</summary>
Funcionalidades que vamos a implementar:

- Funcionalidades de Registro e inicio de sesi√≥n.(V√≠ctor)
- Que los usuarios puedan tener contactos o conversaci√≥n con t√©cnicos inform√°ticos.(Hugo)
- Los usuarios pueden crear una tabla de t√©cnicos inform√°ticos. (V√≠ctor)


Seguridad (en funci√≥n de vuestro proyecto):

- MongoDB
- Protecci√≥n de c√≥digo fuente
- toda la parte de monitorizaci√≥n y seguridad que vais a implementar
</details>
<br>



<details>
<summary>üñ•Ô∏è Arquitectura del Sistema</summary>
Estos seran los componentes de tecnolog√≠a que utilizaremos en el sistema:

- **NGINX:** Servidor web y proxy inverso que gestiona eficazmente el tr√°fico y balancea la carga de las aplicaciones.

- **MongoDB:** Base de datos NoSQL que almacena documentos en lugar de tablas, ideal para manejar grandes vol√∫menes de datos no estructurados.

- **PHP:** Lenguaje de programaci√≥n del lado del servidor, usado para generar contenido din√°mico en p√°ginas web.

- **HTML:** Lenguaje para estructurar y organizar el contenido de una p√°gina web.

- **CSS:** Lenguaje para aplicar estilos y dise√±os visuales a las p√°ginas web.

- **JS:** Lenguaje para agregar interactividad y funcionalidades en el navegador.

- **Bind9:** Servidor DNS que traduce nombres de dominio a direcciones IP.

- **Docker:** Plataforma que facilita la creaci√≥n y gesti√≥n de contenedores para ejecutar aplicaciones de manera aislada.

- **Jabberd:** Servidor de mensajer√≠a instant√°nea basado en el protocolo XMPP.

- **Composer:** Herramienta para gestionar las dependencias y bibliotecas en proyectos PHP.

- **WebSocket:** Protocolo para comunicaci√≥n bidireccional en tiempo real entre cliente y servidor.

- **IPTables:** Herramienta en Linux para configurar un firewall y controlar el tr√°fico de red.



</details>
<br>


<details>
<summary>üì¶‚òÅÔ∏èMaquinas Virtuales</summary>

<br>


<details>
<summary>+----------üåêüîÑüñ•Ô∏è DNS</summary>

  
</details>
<br>


<details>
<summary>+----------üåêüñ•Ô∏è WEB/NGINX</summary>

  
</details>
<br>


<details>
<summary>+----------üçÉüóÉÔ∏è MongoDB</summary>

  
</details>
<br>


<details>
<summary>+----------üë§ Cliente</summary>

  
</details>
<br>


<details>
<summary>+----------üê≥ Docker</summary>

  
</details>
<br>


<details>
<summary>+----------üìß Server Email</summary>

  
</details>
<br>


<details>
<summary>+----------üíæüîí Backup/Recuperaci√≥n</summary>

  
</details>
<br>



<details>
<summary>+----------üêß Sistemas Operativos</summary>

Estos son los Sistemas Operativos que vamos a implementar en la Maquina virtuales.


- Ubuntu Server
  
- Alpine (Docker)

- Firewall


  
</details>
<br>




<details>
<summary>+----------üî≤ Hardware</summary>

Todas las VM tienen la misma capacidad de memoria RAM, CPU y disco duro, menos la VM Docker.

MV:
- RAM --> 2 GB
- CPU --> 1 (1 socket & 1 cores)
- HD --> 14 GB
<br>

MV Docker:
- RAM --> 4 GB
- CPU --> 4 (2 sockets & 2 cores)
- HD --> 60 GB

  
</details>

</details>
  
<br>

<details>
<summary>üõ°Ô∏èSeguridad</summary>

<br>

<details>
<summary>+----------üí† Tipos de Seguridad</summary>

# üî• Protecci√≥n contra ataques (DDoS, Hydra, etc.)

<br>

## 1Ô∏è‚É£ En el Router/Ubuntu (Entrada de la red)

üìå Motivo: Es el primer punto de entrada y debe filtrar tr√°fico malicioso antes de que llegue a los servidores internos.

‚úÖ Medidas:

* Firewall (iptables, UFW): Restringir accesos por IP y puertos.

* Sistema de Prevenci√≥n de Intrusos (IPS) como Fail2Ban o Suricata: Detectar y bloquear intentos de fuerza bruta (Hydra).

* Protecci√≥n contra DDoS (Cloudflare, iptables con rate limiting, servicios de mitigaci√≥n DDoS como AWS Shield o Cloudflare).

* VPN (WireGuard, OpenVPN): Para acceso seguro de administradores.

<br>

## 2Ô∏è‚É£ Servidor Web

üìå Motivo: Objetivo principal de ataques como DDoS, SQL Injection y explotaci√≥n de vulnerabilidades.

‚úÖ Medidas:

* WAF (Web Application Firewall) como ModSecurity: Bloqueo de ataques a la aplicaci√≥n web.

* Limitaci√≥n de conexiones simult√°neas con herramientas como fail2ban.

* TLS/SSL para cifrar la comunicaci√≥n HTTPS.

<br>

## 3Ô∏è‚É£ Servidor Base de Datos

üìå Motivo: Contiene informaci√≥n sensible y puede sufrir SQL Injection o ataques de fuerza bruta.

‚úÖ Medidas:

* Permitir conexiones solo desde el servidor web (bloquear accesos externos).

* Cifrar datos sensibles en la base de datos.

* Autenticaci√≥n fuerte y rotaci√≥n de contrase√±as.

<br>

## 4Ô∏è‚É£ Docker

üìå Motivo: Puede contener aplicaciones con vulnerabilidades explotables.

‚úÖ Medidas:

* Restringir acceso a contenedores con redes privadas.

* Escanear im√°genes con herramientas como Trivy.

* Configurar permisos m√≠nimos en los contenedores.

<br>

## 5Ô∏è‚É£ Servidor de Correo

üìå Motivo: Sujeto a ataques de phishing y fuerza bruta (SMTP, IMAP, POP3).

‚úÖ Medidas:

* SPF, DKIM y DMARC para evitar suplantaci√≥n de identidad.

* Rate limiting para prevenir ataques de fuerza bruta.

* Filtrado de spam con herramientas como SpamAssassin.

<br>

## 6Ô∏è‚É£ Servidor DNS

üìå Motivo: Puede ser objetivo de ataques de envenenamiento de cach√© o DDoS.

‚úÖ Medidas:

* DNSSEC para validar respuestas DNS.

* Rate limiting en consultas para mit


</details>




<br>

<details>
<summary>+----------üìÑüõ°Ô∏è Backup (Copias de Segiridad)</summary>

**https://www.incibe.es/sites/default/files/contenidos/guias/guia-copias-de-seguridad.pdf**
  
# ¬øQu√© es una copia de seguridad y que importancia tiene?

Una copia de seguridad es un proceso que permite duplicar y almacenar informaci√≥n con el fin de recuperarla en caso de p√©rdida o fallo del sistema. En el √°mbito empresarial, resulta fundamental para garantizar la continuidad del negocio y mantener la confianza de los clientes. Forma parte de los planes de seguridad y contingencia, asegurando la protecci√≥n, disponibilidad y recuperaci√≥n de los datos de manera eficiente y peri√≥dica.

Imagina que tienes un cuaderno en el que anotas informaci√≥n crucial para tu escuela. Si lo pierdes o se da√±a, toda esa informaci√≥n desaparecer√≠a, lo que ser√≠a un gran problema. Lo mismo ocurre con los datos de un negocio: si no se cuenta con una copia de seguridad, cualquier fallo, error humano o ciberataque podr√≠a ocasionar la p√©rdida definitiva de informaci√≥n valiosa.
Por ello, realizar copias de seguridad regularmente es esencial. Es como tener una segunda versi√≥n de tu cuaderno guardada en un lugar seguro, lista para ser utilizada en caso de emergencia, evitando as√≠ p√©rdidas irreparables y garantizando la estabilidad de la informaci√≥n.


# ¬øQu√© copias de seguridad hariamosa?
Para definir qu√© informaci√≥n debe incluirse en las copias de seguridad, primero es necesario realizar un inventario de activos y clasificar los datos seg√∫n su importancia para el negocio. Esta clasificaci√≥n nos permitir√° priorizar la protecci√≥n de la informaci√≥n cr√≠tica y definir estrategias adecuadas de respaldo:

* Confidencialidad: (confidencial, interna, p√∫blica).

* Utilidad: (clientes, ventas, personal).

* Impacto: (da√±o de imagen, consecuencias legales, econ√≥micas, paralizaci√≥n de la actividad).

Esto ayuda a establecer medidas de seguridad y decidir qu√© informaci√≥n proteger, como datos de clientes, ventas o personal, y su frecuencia de respaldo.


# ¬øQu√© estrategias seguir√≠amos?
Para garantizar la seguridad y disponibilidad de nuestros datos, aplicaremos la estrategia 3-2-1 de copias de seguridad, una de las mejores pr√°cticas en la gesti√≥n de respaldos. Su objetivo es diversificar el almacenamiento de las copias para minimizar el riesgo de p√©rdida de informaci√≥n y asegurar la posibilidad de recuperaci√≥n en caso de fallo. Sus principios clave son:

* 3 copias: Mantener tres versiones de cada archivo importante: el original y al menos dos copias de respaldo.
* 2 soportes diferentes: Almacenar las copias en al menos dos tipos de medios distintos (por ejemplo, un disco duro externo y almacenamiento en la nube) para mitigar riesgos como fallos mec√°nicos o corrupci√≥n de datos.
* 1 copia fuera de la empresa: Guardar al menos una copia en una ubicaci√≥n externa (como un servicio de almacenamiento en la nube) para proteger la informaci√≥n ante desastres f√≠sicos, robos o ciberataques en la infraestructura local.

Ejemplo pr√°ctico
Si trabajamos con un archivo cr√≠tico llamado "listadoproveedores.ots", podr√≠amos aplicar la estrategia 3-2-1 de la siguiente manera:

* Archivo original: Se almacena en el equipo principal donde se trabaja con √©l.
* Primera copia de seguridad: Se guarda en un disco duro externo o servidor NAS local.
* Segunda copia de seguridad: Se sube a un servicio de almacenamiento en la nube (cumpliendo tambi√©n con la regla de "ubicaci√≥n externa").


# ¬øD√≥nde se van a ubicar las copias?

Por el momento, almacenaremos nuestras copias de seguridad en Google Drive y en discos duros externos como medida preventiva ante cualquier incidente inesperado, garantizando que siempre tengamos acceso a nuestros datos en caso de fallos o imprevistos.

Adem√°s, hemos decidido implementar un sistema de almacenamiento en la nube para reforzar a√∫n m√°s la seguridad y disponibilidad de la informaci√≥n. Actualmente, estamos en proceso de evaluaci√≥n y configuraci√≥n de este servicio, asegur√°ndonos de elegir la mejor opci√≥n en t√©rminos de fiabilidad, cifrado y accesibilidad.

Tambi√©n crearemos una m√°quina virtual en Proxmox que funcionar√° como servidor central para almacenar toda la informaci√≥n, bases de datos y c√≥digo fuente de nuestro proyecto. Adem√°s, configuraremos copias de seguridad automatizadas y medidas de seguridad como firewalls y cifrado para garantizar la integridad y protecci√≥n de los datos.


# Esto sera la informaci√≥n que copiaremos para asegurar nuestro proyecto:

* Base de Datos: La informaci√≥n de los usuarios y datos cr√≠ticos de la empresa deben resguardarse con la mayor frecuencia posible. Un respaldo frecuente y seguro es clave para evitar p√©rdidas de informaci√≥n valiosa.

* DNS: El DNS es fundamental para el funcionamiento de los servicios en l√≠nea, asegurando que los dominios est√©n correctamente direccionados. Un backup del DNS garantiza que la infraestructura web siga operativa en caso de fallos.

* C√≥digo de la Web y Nginx: Resguardar el c√≥digo fuente de la web junto con la configuraci√≥n de Nginx es esencial para una r√°pida recuperaci√≥n en caso de incidentes o ataques.

* Router: Mantener una copia de seguridad de la configuraci√≥n del router es crucial para garantizar la conectividad de la red y facilitar su restauraci√≥n en caso de fallas o modificaciones accidentales.



# C√≥digos del Backup
## Copias de seguridad
Hemos creado este script en Bash para automatizar la copia de seguridad cifrada de archivos desde servidores remotos a un sistema local. Su objetivo es garantizar que los respaldos sean descargados, cifrados y almacenados de forma segura, manteniendo un historial controlado mediante la gesti√≥n de copias previas y registros en un archivo de log. A continuaci√≥n, os mostraremos que hace cada parte del c√≥digo:

1. Configuraci√≥n de usuarios de los ordenadores de destino, IPs de los ordenadores, carpeta local de respaldo, rutas en los ordenadores remotos, carpeta de logs, formato de fecha y hora; y archivo de log.
2. Crear la carpeta de logs si no existe.
3. Redirigir la salida est√°ndar y los errores al archivo de log.
4. Escribir en el log el inicio de la ejecuci√≥n.
5. Preguntar al usuario a qui√©n desea enviar los archivos.
6. Verificar si el usuario ingresado es v√°lido.
7. Obtener el √≠ndice del usuario seleccionado.
8. Verificar si el √≠ndice fue encontrado.
9. Obtener las configuraciones correspondientes para el usuario seleccionado.
10. Buscar los archivos de respaldo espec√≠ficos para el usuario seleccionado.
11. Verificar si se han encontrado archivos de respaldo.
12. Verificar si el destino est√° accesible.
13. Bucle para enviar los archivos de respaldo.

```
#!/bin/bash

# Configuraci√≥n
USUARIOS_ORIGEN=("hugo" "cliente")  # Lista de usuarios en diferentes ordenadores
IPS_ORIGEN=("192.168.6.10" "192.168.6.11")  # IPs de los ordenadores remotos
CARPETAS_ORIGEN=("/home/hugo/origen" "/home/cliente/origen")  # Rutas de las carpetas a copiar
CARPETA_DESTINO="/home/hugo/buckup-all/destino"  # Se guardar√° en el equipo local
CARPETA_TEMP="/tmp/backup_encrypt"
SCRIPT_DIR="$(dirname "$(realpath "$0")")"  # Obtiene la ruta del script
LOG_DIR="$SCRIPT_DIR/logs"
TIMESTAMP="$(date '+%H.%M_%d-%m-%Y')"  # Formato de fecha y hora
LOG_FILE="$LOG_DIR/backup_$TIMESTAMP.log"
CLAVE_CIFRADO="alumno"

# Crear carpeta de logs si no existe
mkdir -p "$LOG_DIR"

# Redirigir salida est√°ndar y errores al archivo de log
exec >> "$LOG_FILE" 2>&1

echo "[$(date)] - Iniciando respaldo remoto con cifrado..."

# Verificar que las listas de usuarios, IPs y carpetas tengan la misma cantidad de elementos
if [ ${#USUARIOS_ORIGEN[@]} -ne ${#IPS_ORIGEN[@]} ] || [ ${#USUARIOS_ORIGEN[@]} -ne ${#CARPETAS_ORIGEN[@]} ]; then
    echo "[$(date)] - Error: Las listas de usuarios, IPs y carpetas de origen deben tener la misma cantidad de elementos."
    exit 1
fi

# Bucle para procesar cada origen
for i in "${!USUARIOS_ORIGEN[@]}"; do
    USUARIO_ORIGEN="${USUARIOS_ORIGEN[$i]}"
    IP_ORIGEN="${IPS_ORIGEN[$i]}"
    CARPETA_ORIGEN="${CARPETAS_ORIGEN[$i]}"

    echo "[$(date)] - Conectando a $USUARIO_ORIGEN@$IP_ORIGEN..."
    
    # Verificar conexi√≥n SSH con el equipo remoto
    if ! nc -z "$IP_ORIGEN" 22; then
        echo "[$(date)] - Error: No se puede conectar a $IP_ORIGEN en el puerto 22."
        continue  # Continuar con el siguiente origen si no se puede conectar
    fi

    # Crear carpeta temporal para los archivos cifrados
    mkdir -p "$CARPETA_TEMP"

    # Copiar archivos desde el equipo remoto
    echo "[$(date)] - Descargando archivos desde el servidor remoto $IP_ORIGEN..."
    if rsync -avz -e "ssh -p 22" "$USUARIO_ORIGEN@$IP_ORIGEN:$CARPETA_ORIGEN/" "$CARPETA_TEMP/"; then
        echo "[$(date)] - Archivos descargados con √©xito desde $IP_ORIGEN."
    else
        echo "[$(date)] - Error: Fallo en la sincronizaci√≥n con rsync desde $IP_ORIGEN."
        rm -rf "$CARPETA_TEMP"
        continue  # Continuar con el siguiente origen si rsync falla
    fi

    # Crear carpeta espec√≠fica para el usuario en el destino
    USUARIO_DESTINO="$CARPETA_DESTINO/$USUARIO_ORIGEN"
    mkdir -p "$USUARIO_DESTINO"

    # Gestionar el n√∫mero m√°ximo de copias (3)
    echo "[$(date)] - Verificando copias anteriores en $USUARIO_DESTINO..."
    ARCHIVOS_ANTIGUOS=($(ls -t $USUARIO_DESTINO/backup_${USUARIO_ORIGEN}_*.tar.gz.gpg))
    NUM_COPIAS=${#ARCHIVOS_ANTIGUOS[@]}
    
    if [ $NUM_COPIAS -ge 3 ]; then
        # Eliminar las copias m√°s antiguas (mantener solo las 2 m√°s recientes)
        ARCHIVOS_A_ELIMINAR=("${ARCHIVOS_ANTIGUOS[@]:2}")
        echo "[$(date)] - Eliminando copias antiguas: ${ARCHIVOS_A_ELIMINAR[@]}"
        rm -f "${ARCHIVOS_A_ELIMINAR[@]}"
    fi

    # Cifrar archivos manteniendo la estructura original
    echo "[$(date)] - Cifrando archivos descargados desde $IP_ORIGEN..."
    tar -czf - -C "$CARPETA_TEMP" . | \
    gpg --symmetric --cipher-algo AES256 --passphrase "$CLAVE_CIFRADO" --batch -o "$USUARIO_DESTINO/backup_${USUARIO_ORIGEN}_${TIMESTAMP}.tar.gz.gpg"

    if [ $? -eq 0 ]; then
        echo "[$(date)] - Respaldo cifrado de $USUARIO_ORIGEN almacenado en: $USUARIO_DESTINO/backup_${USUARIO_ORIGEN}_${TIMESTAMP}.tar.gz.gpg"
    else
        echo "[$(date)] - Error en el cifrado del respaldo desde $IP_ORIGEN."
    fi

    # Limpiar archivos temporales
    rm -rf "$CARPETA_TEMP"

done

# Instrucciones para descifrar
echo "[$(date)] - Para descifrar en este equipo, ejecutar:"
echo "  gpg --decrypt --passphrase \"$CLAVE_CIFRADO\" --batch $CARPETA_DESTINO/<usuario>/backup_<usuario>_<timestamp>.tar.gz.gpg | tar -xz -C $CARPETA_DESTINO/<usuario>"

echo "[$(date)] - Respaldo finalizado."
```

<br>


## Recuperaci√≥n de las copias de seguridad
Hemos creado este script para transferir copias de seguridad cifradas (.tar.gz.gpg) desde una m√°quina local a un servidor remoto, asegurando que los respaldos sean enviados de manera segura y organizada. Su prop√≥sito es automatizar la transferencia de respaldos mientras se registran los eventos en un archivo de log para garantizar trazabilidad. A continuaci√≥n, se describe brevemente c√≥mo funciona.

1. Tenemos la configuraci√≥n de los usuarios en los ordenes de destino, IPs, carpeta local donde esta respaldado, rutas en los ordenadores remotos, carpetas log, formato de la fecha y hora; y el archivo log.
2. Crear la carpeta de logs si no existe.
3. Redirigir la salida est√°ndar y los errores al archivo de log.
4. Escribir en el log el inicio de la ejecuci√≥n.
5. Preguntar al usuario a qui√©n desea enviar los archivos.
6. Verificar si el usuario ingresado es v√°lido.
7. Obtener el √≠ndice del usuario seleccionado.
8. Verificar si el √≠ndice fue encontrado.
9. Obtener las configuraciones correspondientes para el usuario seleccionado.
10. Buscar los archivos de respaldo espec√≠ficos para el usuario seleccionado.
11. Verificar si se han encontrado archivos de respaldo.
12. Verificar si el destino est√° accesible.
13. Bucle para enviar los archivos de respaldo.

```
#!/bin/bash

# Configuraci√≥n
USUARIOS_DESTINO=("hugo" "cliente")  # Usuarios en los ordenadores de destino
IPS_DESTINO=("192.168.6.10" "192.168.6.11")  # IPs de los ordenadores de destino
CARPETA_DESTINO_LOCAL="/home/hugo/buckup-all/destino"  # Carpeta local donde est√°n los respaldos
CARPETA_DESTINO_REMOTO=("/home/hugo/recuperacion" "/home/cliente/recuperacion")  # Rutas en los ordenadores remotos
LOG_DIR="/home/hugo/buckup-all/logs-recup"  # Carpeta de logs
TIMESTAMP="$(date '+%H.%M_%d-%m-%Y')"  # Formato de fecha y hora
LOG_FILE="$LOG_DIR/transferencia_$TIMESTAMP.log"  # Archivo de log

# Crear la carpeta de logs si no existe
mkdir -p "$LOG_DIR"

# Redirigir la salida est√°ndar y los errores al archivo de log
exec >> "$LOG_FILE" 2>&1

# Escribir en el log el inicio de la ejecuci√≥n
echo "[$(date)] - Iniciando transferencia de respaldos."

# Preguntar al usuario a qui√©n desea enviar los archivos
echo "[$(date)] - ¬øA qu√© ordenador deseas enviar los archivos? (hugo/cliente)"
read -p "Escribe 'hugo' o 'cliente': " USUARIO_SELECCIONADO

# Verificar si el usuario ingresado es v√°lido
if [[ ! " ${USUARIOS_DESTINO[@]} " =~ " ${USUARIO_SELECCIONADO} " ]]; then
    echo "[$(date)] - Error: Usuario '$USUARIO_SELECCIONADO' no v√°lido. Selecciona entre 'hugo' o 'cliente'."
    exit 1
fi

# Obtener el √≠ndice del usuario seleccionado
INDEX=-1
for i in "${!USUARIOS_DESTINO[@]}"; do
    if [ "${USUARIOS_DESTINO[$i]}" == "$USUARIO_SELECCIONADO" ]; then
        INDEX=$i
        break
    fi
done

# Verificar si el √≠ndice fue encontrado
if [ $INDEX -eq -1 ]; then
    echo "[$(date)] - Error: No se encontr√≥ el √≠ndice del usuario seleccionado."
    exit 1
fi

# Obtener las configuraciones correspondientes para el usuario seleccionado
USUARIO_DESTINO="${USUARIOS_DESTINO[$INDEX]}"
IP_DESTINO="${IPS_DESTINO[$INDEX]}"
CARPETA_DESTINO_USUARIO="${CARPETA_DESTINO_REMOTO[$INDEX]}"

# Buscar los archivos de respaldo espec√≠ficos para el usuario seleccionado
ARCHIVOS_ANTIGUOS=($(ls $CARPETA_DESTINO_LOCAL/$USUARIO_DESTINO/backup_*.tar.gz.gpg 2>/dev/null))

# Verificar si se han encontrado archivos de respaldo
if [ ${#ARCHIVOS_ANTIGUOS[@]} -eq 0 ]; then
    echo "[$(date)] - Error: No hay archivos de respaldo para enviar para el usuario $USUARIO_DESTINO en la carpeta $CARPETA_DESTINO_LOCAL/$USUARIO_DESTINO."
    exit 1
fi

# Verificar si el destino est√° accesible
echo "[$(date)] - Conectando a $USUARIO_DESTINO@$IP_DESTINO..."

if ! nc -z "$IP_DESTINO" 22; then
    echo "[$(date)] - Error: No se puede conectar a $IP_DESTINO en el puerto 22."
    exit 1
fi

# Bucle para enviar los archivos de respaldo
for archivo in "${ARCHIVOS_ANTIGUOS[@]}"; do
    echo "[$(date)] - Enviando archivo $archivo a $USUARIO_DESTINO@$IP_DESTINO:$CARPETA_DESTINO_USUARIO..."
    
    # Usar rsync para transferir el archivo de respaldo al destino remoto
    if rsync -avz -e "ssh -p 22" "$archivo" "$USUARIO_DESTINO@$IP_DESTINO:$CARPETA_DESTINO_USUARIO/"; then
        echo "[$(date)] - Archivo $archivo enviado exitosamente a $USUARIO_DESTINO@$IP_DESTINO."
    else
        echo "[$(date)] - Error al enviar el archivo $archivo a $USUARIO_DESTINO@$IP_DESTINO."
    fi
done

echo "[$(date)] - Transferencia de respaldos finalizada."

```
<br>


## Autenticaci√≥n SSH sin Contrase√±a para un Script

Para evitar que el script solicite una contrase√±a al ejecutar los comandos SSH y rsync, debes configurar la autenticaci√≥n sin contrase√±a mediante claves SSH.


### Generar una clave SSH en el cliente



```
ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N ""

```

Esto generar√° un par de claves:

* ~/.ssh/id_rsa (clave privada)
* ~/.ssh/id_rsa.pub (clave p√∫blica)



### Copiar la clave p√∫blica al servidor destino

Usa el siguiente comando para copiar autom√°ticamente la clave p√∫blica al servidor:

```
ssh-copy-id hugo@192.168.6.10

```

Si no tienes ssh-copy-id, puedes hacerlo manualmente con:

```
cat ~/.ssh/id_rsa.pub | ssh hugo@192.168.6.10 "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys"

```

### Verificar la autenticaci√≥n sin contrase√±a

Prueba iniciar sesi√≥n en el servidor sin que te pida la contrase√±a:

```
ssh hugo@192.168.6.10

```
<br>
<br>


## Recibir las copias a la carpeta destino

El comando sudo chown -R hugo:hugo /home/hugo/buckup cambia el propietario y el grupo de todos los archivos y subdirectorios dentro de /home/hugo/buckup al usuario hugo

```
sudo chown -R hugo:hugo /home/hugo/buckup

```

* sudo: Ejecuta el comando con privilegios de superusuario.

* chown: Cambia el propietario de un archivo o directorio.

* -R: Aplica el cambio de propietario de forma recursiva (a todos los archivos y subdirectorios dentro de /home/hugo/buckup).

* hugo:hugo : Establece el usuario propietario como hugo y el grupo como hugo.

* /home/hugo/buckup: Especifica la carpeta a la que se aplicar√° el cambio.

<br>


Establece permisos de lectura, escritura y ejecuci√≥n para el propietario, y solo lectura y ejecuci√≥n para el grupo y otros usuarios en los archivos dentro de /home/hugo/destino.

```
sudo chmod -R 755 /home/hugo/destino

```

* sudo: Ejecuta el comando con privilegios de superusuario.

* chmod: Modifica los permisos de archivos o directorios.

* -R: Aplica el cambio de permisos recursivamente a todos los archivos y subdirectorios dentro del directorio.

* 755: Establece los permisos de lectura, escritura y ejecuci√≥n para el propietario (7 = lectura, escritura y ejecuci√≥n), y solo lectura y ejecuci√≥n para el grupo y los otros usuarios (5 = lectura y ejecuci√≥n).

* /home/hugo/destino: Especifica la ruta del directorio al cual se le aplican los permisos.


<br>
<br>


## Recibir las copias a la carpeta de recuperaci√≥n

El comando sudo chown -R hugo:hugo /home/hugo/buckup cambia el propietario y el grupo de todos los archivos y subdirectorios dentro de /home/hugo/buckup al usuario hugo

```
sudo chown -R hugo:hugo /home/hugo/buckup

```

* sudo: Ejecuta el comando con privilegios de superusuario.

* chown: Cambia el propietario de un archivo o directorio.

* -R: Aplica el cambio de propietario de forma recursiva (a todos los archivos y subdirectorios dentro de /home/hugo/buckup).

* hugo:hugo : Establece el usuario propietario como hugo y el grupo como hugo.

* /home/hugo/buckup: Especifica la carpeta a la que se aplicar√° el cambio.

<br>
<br>


El comando sudo chmod -R u+w /home/hugo/buckup otorga permisos de escritura al usuario propietario en todos los archivos y subdirectorios dentro de /home/hugo/buckup, recursivamente.

```
sudo chmod -R u+w /home/hugo/buckup

```

* sudo: Ejecuta el comando con privilegios de superusuario.

* chmod: Modifica los permisos de archivos o directorios.

* -R: Aplica los cambios de permisos recursivamente.

* -u+w: Agrega permiso de escritura (+w) al usuario propietario (u).

* /home/hugo/buckup: Carpeta a la que se aplicar√° el cambio.


</details>
<br>



<details>
<summary>+----------üß±üî• PFSense</summary>

# ¬øQu√© es PFSense?
Es una distribuci√≥n de **FreeBSD** adaptada como **firewall** y **router**. Es de c√≥digo abierto y se puede instalar en dispositivos f√≠sicos y virtuales. Est√° respaldada comercialmente por **Electric Sheep Fencing LLC**, adem√°s de ser de c√≥digo abierto.
**PfSense** proporciona funciones avanzadas de seguridad y redes, y es conocida por ser una soluci√≥n de firewall de alto rendimiento. A continuaci√≥n, mostramos algunas caracter√≠sticas clave:



* **Firewall avanzado:** Permite configurar reglas de firewall para filtrar y controlar el tr√°fico de red de manera efectiva.
* **Enrutamiento:** Funciona como un router que proporciona funciones de enrutamiento avanzadas y permite la conectividad entre redes.
* **VPN:** Proporciona soporte para VPNs, permitiendo conexiones seguras a trav√©s de redes p√∫blicas.
* **Proxy y filtrado web:** Ofrece funciones de proxy y filtrado web para controlar el acceso a Internet y mejorar la seguridad.
* **Balanceo de carga y redundancia:** Permite distribuir el tr√°fico entre varios servidores y garantizar la disponibilidad en caso de fallos.
* **Seguridad:** Incluye herramientas y configuraciones avanzadas para asegurar las redes y proteger contra ataques.
* **Interfaz gr√°fica:** Cuenta con una interfaz web f√°cil de usar para gestionar y configurar el sistema de forma eficiente.


## Configuraci√≥n de la interfaz LAN

Para configurar la direcci√≥n IP de la interfaz LAN, seleccionamos la opci√≥n n√∫mero 2. A continuaci√≥n, los pasos que nos aparecer√°n:

1. Nos preguntar√° si queremos configurarlo v√≠a DHCP, debemos responder no.
2. A√±adimos la nueva direcci√≥n IP: **192.168.56.110**.
3. Nos preguntar√° qu√© m√°scara de subred utilizaremos: 24.
4. Luego presionamos **ENTER**
5. Nos preguntar√° si queremos configurar una direcci√≥n IPv6 en la interfaz LAN. Respondemos no y presionamos **ENTER**.
6. Luego nos preguntar√° si queremos habilitar un servidor DHCP en la LAN. Respondemos s√≠. A√±adimos el inicio del rango de IP para los clientes (**192.168.56.150**) y el final del rango (**192.168.56.160**).



## Configuraci√≥n de la interfaz WAN
La interfaz WAN se utiliza para conectarse a Internet. Normalmente, se configura con DHCP si el proveedor de servicios de Internet (ISP) asigna direcciones din√°micas, aunque tambi√©n se puede configurar con una IP est√°tica.

1. Desde el men√∫ principal, selecciona la opci√≥n
   
```
2) Set interface(s) IP address.
```

3. Selecciona la interfaz WAN, en este caso:

```
1 - WAN (em0 - dhcp)
```

3. Selecciona el tipo de configuraci√≥n IP:

  * DHCP: Si el ISP asigna la IP autom√°ticamente (opci√≥n recomendada para la mayor√≠a de los casos).

  * Est√°tica: Si tienes una IP fija proporcionada por tu ISP.

4. Si es IP est√°tica, introduce:

  * Direcci√≥n IP (por ejemplo, **```192.168.1.2```**).

  * M√°scara de subred (por ejemplo, **```255.255.255.0```**).

  * Puerta de enlace (IP del router del ISP, por ejemplo, ```192.168.1.1```).

5.¬øConfigurar IPv6?

  * Si tu ISP lo soporta, puedes configurarlo o dejarlo en autom√°tico.

6. ¬øActivar servidor DHCP en esta interfaz?

  * Para la interfaz WAN, generalmente seleccionamos No.

7. Confirmar y aplicar cambios.

<br>
<br>

## Configuraci√≥n de la interfaz LAN
La interfaz LAN se usa para la red interna y suele tener una direcci√≥n IP est√°tica.

1. Desde el men√∫ principal, selecciona ```2) Set interface(s) IP address```.

2. Selecciona la interfaz LAN, en este caso:

```
2 - LAN (em1 - static)
```

3. Configura la IP de LAN, por ejemplo:

* Direcci√≥n IP: ```192.168.1.1``` (IP del router dentro de la red local).

* M√°scara de subred: ```255.255.255.0```.

4. Configurar IPv6:

   Puedes desactivarlo si no lo necesitas o usarlo si tu red lo soporta.

6. ¬øActivar servidor DHCP en LAN?

* S√≠ (para que los dispositivos en la red obtengan IP autom√°ticamente).

* Especifica un rango de IPs, por ejemplo:

  * Inicio: ```192.168.1.100```

  * Fin: ```192.168.1.200```

6. Confirmar y aplicar cambios.



![image](https://github.com/user-attachments/assets/b3f88415-07a5-4233-b5e2-9fdbbb605306)

<br>
<br>
<br>
<br>

Para poder acceder a **pfSense** en modo gr√°fico, debes ingresar la direcci√≥n IP en el navegador de una m√°quina conectada a la red LAN, siempre que esta tenga habilitado el acceso al modo gr√°fico.

![image](https://github.com/user-attachments/assets/52450081-dc1d-4086-9f1c-1d48ce3d9e75)


Tendremos que activar **Kea DHCP**, que se encarga de asignar direcciones IP din√°micamente. Mejora el rendimiento, permite configuraciones sin necesidad de reiniciar, soporta bases de datos externas y facilita la administraci√≥n remota mediante API.

![image](https://github.com/user-attachments/assets/848e501c-bf3b-4d85-b0d3-725bb8bdb75e)

<br>
<br>

# ¬øQu√© es OpenVPN?

**OpenVPN** es una soluci√≥n de software libre para crear redes privadas virtuales (VPN). Permite establecer una conexi√≥n segura y cifrada entre dispositivos a trav√©s de una red no segura, como **Internet**. Es utilizado para proteger la privacidad en l√≠nea, asegurar la comunicaci√≥n entre dispositivos remotos y permitir el acceso a redes internas de forma segura.

![imagen_2025-03-14_101252810-removebg-preview](https://github.com/user-attachments/assets/e9237aa2-1a9e-4c13-a7f4-1e6642275050)

## ‚úÖ Ventajas
* **Seguridad robusta:** Utiliza cifrado de alta calidad (**AES, SSL/TLS**) para garantizar que los datos transmitidos est√©n protegidos contra intercepciones.

* **Flexibilidad:** Puede ser configurado para funcionar en diferentes plataformas (**Windows, Linux, macOS, Android, iOS**) y ser usado tanto en redes locales como remotas.

*  **C√≥digo abierto:** **OpenVPN** es gratuito y tiene una comunidad activa que contribuye a su mejora constante.

*  **Acceso remoto seguro:** Ideal para acceder de forma segura a redes privadas desde cualquier lugar del mundo.

*  **Escalabilidad:** Puede manejar desde peque√±as instalaciones hasta grandes redes corporativas.

## ‚ùå Desventajas
Desventajas de OpenVPN:
* **Configuraci√≥n compleja:** A pesar de ser poderoso, puede resultar complicado de configurar para usuarios sin experiencia, especialmente cuando se necesita ajustar opciones avanzadas.

* **Rendimiento:** En comparaci√≥n con otras soluciones **VPN**, **OpenVPN** puede ser m√°s lento debido a su nivel de cifrado y autenticaci√≥n, aunque este impacto es m√≠nimo si se utiliza un hardware adecuado.

* **Dependencia de certificados:** Requiere la gesti√≥n de certificados y claves para la autenticaci√≥n, lo que puede ser un desaf√≠o si no se tiene experiencia en su administraci√≥n.

* **Requiere software adicional:** Necesita instalar un cliente **OpenVPN** en los dispositivos que se conectan a la red privada, lo que puede ser una limitaci√≥n en algunos entornos.

<br>

# Com√≥ activar OpenVPN

## 1Ô∏è‚É£ Instalar OpenVPN (si no est√° instalado)

OpenVPN viene integrado en pfSense, pero si falta, inst√°lalo desde:

üîπ System > Package Manager > Available Packages > Busca ```OpenVPN``` > Install

## 2Ô∏è‚É£ Configurar el Servidor OpenVPN en pfSense

1. Accede a la interfaz web de pfSense en ```https://192.168.1.1```

<br>

2. Ve a VPN > OpenVPN > Wizards

<br>

3. Selecciona el m√©todo de autenticaci√≥n:

  * Local User Access (usuarios internos) o

  * LDAP/RADIUS (si usas autenticaci√≥n externa)

<br>

4. Crear o usar una **CA** (Certificate Authority)

  * Si no tienes una **CA**, el asistente la generar√°.

  * Crea un certificado de servidor.

<br>

5. Configurar el servidor VPN:

  * Interfaz: ```WAN```

  * Protocolo: ```UDP``` o ```TCP``` (recomendado UDP)

  * Puerto: ```1194``` (puedes cambiarlo)

  * Tunnel Network: ```10.8.0.0/24``` (rango IP de la VPN)

  * Local Network: ```192.168.1.0/24``` (red interna)

  * Activar ```Redirect Gateway``` si quieres que todo el tr√°fico pase por la VPN

<br>

6. Configurar cifrado y seguridad:

  * Cipher: AES-256-CBC o AES-256-GCM

  * Auth Digest Algorithm: SHA256

  * TLS Authentication: Activar

<br>

7. Guardar y aplicar los cambios.

## 3Ô∏è‚É£ Crear reglas de Firewall para OpenVPN

1. Ve a Firewall > Rules > OpenVPN

<br>

2. A√±ade una regla:

  * Acci√≥n: ```Pass```

  * Protocolo: ```Any```

  * Fuente: ```OpenVPN```

  * Destino: ```Any```

  * Guardar y aplicar.

Tambi√©n, en Firewall > NAT, agrega una regla para permitir tr√°fico desde la VPN.



## 4Ô∏è‚É£ Crear Usuarios y Certificados

1.Ve a System > User Manager

<br>

2. A√±ade un usuario, activa "Certificate" y genera uno nuevo.

## 5Ô∏è‚É£ Exportar el perfil OpenVPN para clientes

1. Instala el paquete OpenVPN Client Export desde System > Package Manager.

<br>

2. Ve a VPN > OpenVPN > Client Export.

<br>

3. Descarga el archivo ```.ovpn``` para conectarte desde Windows, macOS, Linux o m√≥viles.

## 6Ô∏è‚É£ Conectar un Cliente OpenVPN

* Instala OpenVPN Client en tu PC o m√≥vil.

* Importa el archivo ```.ovpn``` y con√©ctate.


<br>
<br>
<br>
<br><br>
<br>
<br>
<br><br>
<br>
<br>
<br>






</details>

<br>

<details>
<summary>+----------üîêüíªCifrado de punto a punto</summary>

# Qu√© es el Cifrado punto a punto

El cifrado punto a punto (tambi√©n conocido como cifrado **end-to-end**, o **E2EE**, por sus siglas en ingl√©s) es un m√©todo de seguridad de comunicaci√≥n que asegura que solo el emisor y el receptor de la informaci√≥n puedan leer los mensajes que se env√≠an entre ellos.

![image](https://github.com/user-attachments/assets/45ede1e2-9629-4226-bec5-d94b1ac05ed3)

<br>

En este tipo de cifrado:

1Ô∏è‚É£ El emisor cifra el mensaje con una clave antes de enviarlo.

2Ô∏è‚É£ El mensaje cifrado se transmite a trav√©s de internet o cualquier otra red, pero incluso si alguien intercepta el mensaje, no podr√° entenderlo, ya que no tiene la clave para descifrarlo.

3Ô∏è‚É£ El receptor usa su propia clave para descifrar el mensaje y leerlo.

Esto garantiza que, incluso si los servidores de la plataforma de comunicaci√≥n son hackeados o las comunicaciones son interceptadas en el camino, los mensajes seguir√°n siendo privados y solo podr√°n ser le√≠dos por las personas a quienes est√°n destinados.

<br>

# end-to-end/WebSocket
El cifrado punto a punto (end-to-end) en WebSocket se logra utilizando una capa de cifrado sobre la comunicaci√≥n WebSocket, asegurando que los datos sean cifrados en el cliente y solo descifrados en el servidor, o viceversa. Esto se puede lograr con TLS (Transport Layer Security), que es el est√°ndar de cifrado utilizado en protocolos como HTTPS.

## Pasos para habilitar cifrado punto a punto en WebSocket:

### 1Ô∏è‚É£ Usar WebSocket sobre WSS (WebSocket Secure)
Al igual que HTTPS para HTTP, WebSocket utiliza WSS para conexiones seguras (cifradas). La wss:// es la versi√≥n segura de WebSocket, que utiliza TLS para cifrar la comunicaci√≥n.
  * En el servidor WebSocket, debes configurar TLS.
  * En el cliente, debes usar wss:// en lugar de ws:// para que la conexi√≥n sea segura.

### 2Ô∏è‚É£ Configurar un servidor WebSocket con TLS 
Si est√°s utilizando un servidor como Node.js con ws o Socket.io, necesitar√°s un certificado SSL/TLS. Aqu√≠ hay un ejemplo b√°sico usando Node.js:

* **Instalaci√≥n:**
```
npm install ws
npm install https
```

* **C√≥digo del servidor con TLS:**
```
const https = require('https');
const fs = require('fs');
const WebSocket = require('ws');

// Cargar los certificados SSL/TLS
const server = https.createServer({
  cert: fs.readFileSync('path/to/certificate.pem'),
  key: fs.readFileSync('path/to/private-key.pem')
});

// Crear el servidor WebSocket
const wss = new WebSocket.Server({ server });

wss.on('connection', ws => {
  ws.on('message', message => {
    console.log('received: %s', message);
  });
  ws.send('Hello secure WebSocket!');
});

server.listen(8080, () => {
  console.log('Secure WebSocket server is running on wss://localhost:8080');
});
```

* **https.createServer()** se usa para crear un servidor HTTPS que tambi√©n soporta WebSocket seguro.
* Necesitar√°s tener un certificado (**certificate.pem**) y una clave privada (**private-key.pem**).

### 3Ô∏è‚É£ Cliente WebSocket con wss://
En el lado del cliente, simplemente usa wss:// para conectar de manera segura al servidor.

**C√≥digo del cliente:**

```
const socket = new WebSocket('wss://localhost:8080');

socket.onopen = function(event) {
  console.log('Conectado al servidor seguro WebSocket');
  socket.send('Hola desde el cliente seguro!');
};

socket.onmessage = function(event) {
  console.log('Mensaje recibido: ', event.data);
};
```

### 4Ô∏è‚É£ Certificados y claves en producci√≥n
* Para entornos de producci√≥n, aseg√∫rate de obtener certificados SSL/TLS v√°lidos de una autoridad de certificaci√≥n (CA) confiable.
* Usa herramientas como Let's Encrypt para obtener certificados SSL gratuitos si es necesario.

<br>

### Consideraciones adicionales
Cifrado de extremo a extremo real: Si deseas realizar un cifrado adicional de los datos antes de enviarlos a trav√©s de WebSocket (m√°s all√° de TLS), podr√≠as cifrar los mensajes con una clave privada del cliente y solo el destinatario podr√≠a descifrarlos. Para esto, puedes usar bibliotecas como CryptoJS o Web Crypto API.

**Ejemplo usando Web Crypto API en el cliente:**

```
async function encryptData(data, publicKey) {
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(data);

  // Usar la clave p√∫blica para cifrar los datos
  const encryptedData = await window.crypto.subtle.encrypt(
    { name: "RSA-OAEP" },
    publicKey,
    dataBuffer
  );

  return encryptedData;
}
```

### Resumen
1. Usa wss:// en lugar de ws:// para asegurarte de que los WebSockets est√©n cifrados usando TLS.

2. En el servidor, configura un certificado SSL/TLS para habilitar la conexi√≥n segura.

3. Si deseas un cifrado real punto a punto, implementa cifrado adicional de los datos (por ejemplo, usando RSA o AES en el lado del cliente y servidor).

<br>

## Ejemplos de aplicaciones que usan cifrado punto a punto:

* WhatsApp
* Signal
* Telegram (en chats secretos)
* iMessage

Este tipo de cifrado es muy popular porque ofrece un alto nivel de privacidad y seguridad, ya que ni siquiera los proveedores del servicio (como las plataformas de mensajer√≠a) tienen acceso a los contenidos de los mensajes.


</details>
</details>


<br>


<details>
  <summary>üíæüçÉ Base de Datos</summary>
  
# Mongo DB

## ¬øQu√© es el Mongo DB?

MongoDB es una base de datos NoSQL orientada a documentos, dise√±ada para manejar grandes vol√∫menes de datos de manera flexible y escalable. A diferencia de las bases de datos relacionales tradicionales (como MySQL o PostgreSQL), MongoDB no usa tablas ni filas, sino que almacena los datos en documentos JSON (BSON, espec√≠ficamente).

![image](https://github.com/user-attachments/assets/7576c635-9443-4c87-a9fd-b5f92e74c768)

<br>

## ¬øPorqu√© estmos utilizando MongoDB y no MySQL?
Elegir MongoDB en lugar de MySQL para tu proyecto de chat estilo Telegram tiene varias ventajas, especialmente en cuanto a la flexibilidad, escalabilidad y desempe√±o en situaciones que requieren alta disponibilidad y rendimiento.

<br>

## üîπ Principales Caracter√≠sticas de MongoDB
    
1Ô∏è‚É£ **Base de datos NoSQL**

  * No utiliza estructuras relacionales (tablas y filas).
  
  * En su lugar, almacena datos en documentos JSON dentro de colecciones.

<br>

2Ô∏è‚É£ **Flexible y escalable**

  * No necesita una estructura fija de datos (esquema flexible).
  
  * Puede escalar horizontalmente (a√±adiendo m√°s servidores) con Sharding.

<br>

3Ô∏è‚É£ **Alto rendimiento**

* Soporta grandes vol√∫menes de datos con lecturas y escrituras r√°pidas.

<br>

4Ô∏è‚É£ **Soporte para consultas avanzadas**

* Puedes hacer consultas complejas con filtros, agregaciones y b√∫squedas avanzadas.

<br>

5Ô∏è‚É£ **Integraci√≥n con m√∫ltiples lenguajes**

* Compatible con Python, JavaScript (Node.js), Java, PHP, etc.

<br>
<br>


## üîπ Ejemplo de c√≥mo funciona MongoDB

üìå Estructura de un documento en MongoDB (similar a un JSON):

```
{
  "_id": ObjectId("60d5f9f4f3a2a2b6c8e5a123"),
  "nombre": "Juan P√©rez",
  "edad": 30,
  "ciudad": "Madrid",
  "hobbies": ["f√∫tbol", "cine", "lectura"]
}
```
* Se almacena dentro de una colecci√≥n (como una tabla en SQL).
* Cada documento puede tener una estructura diferente dentro de la misma colecci√≥n.

<br>
<br>

## üîπ Comparaci√≥n con una Base de Datos Relacional (SQL)

![image](https://github.com/user-attachments/assets/58e22335-33ae-4e32-9479-8e75327e0e6f)

<br>
<br>

## üîπ ¬øCu√°ndo usar MongoDB?

‚úÖ Cuando necesitas manejar grandes vol√∫menes de datos no estructurados.

‚úÖ Para aplicaciones web y m√≥viles con datos din√°micos y flexibles.

‚úÖ Si buscas escalabilidad horizontal para manejar alto tr√°fico.

‚úÖ Para Big Data, IoT y aplicaciones en tiempo real.


<br>
<br>

## üîπ ¬øCu√°ndo NO usar MongoDB?

‚ùå Si necesitas relaciones complejas entre datos (ej. ERP, banca).

‚ùå Cuando requieres transacciones ACID fuertes (ej. sistemas financieros).

‚ùå Si los datos son altamente estructurados y no cambian mucho.


<br>
<br>


## ¬øQu√© es lo que hemos hecho?
Esta es nuestra base de datos en MongoDB Atlas. A continuaci√≥n, os mostraremos las colecciones que contiene y os explicaremos la funci√≥n de cada una de ellas.

![image](https://github.com/user-attachments/assets/0be57b9c-2c76-4fc4-8aeb-04e71d1d4d93)


### Channels
En esta secci√≥n, almacenamos los canales disponibles en nuestra p√°gina web. Aqu√≠ podr√°s ver el nombre del canal, la fecha de creaci√≥n, si es p√∫blico o privado, su estado (activo o inactivo), qui√©n lo cre√≥ y los miembros que forman parte de √©l.

![image](https://github.com/user-attachments/assets/2151207c-312c-47e4-8aaa-de496b998349)


### Files
Aqu√≠ almacenamos los archivos enviados entre usuarios. Podr√°s ver en qu√© canal se envi√≥ el archivo, la hora de env√≠o y el tipo de archivo.

![image](https://github.com/user-attachments/assets/e2ef22cb-ca6b-412e-9a94-f1afa139f570)



### Messages
En esta secci√≥n se almacenan los mensajes enviados entre usuarios y en los canales. Tambi√©n se muestra la fecha en que se envi√≥ cada mensaje.

![image](https://github.com/user-attachments/assets/d6c36f84-5adf-4e20-9633-220c589c6e20)



### Private-Chats
En esta secci√≥n se encuentran los chats privados creados por los usuarios. Podr√°s ver los miembros de cada chat y los mensajes enviados en ellos.

![image](https://github.com/user-attachments/assets/4c1f7e9d-d832-43ed-bf88-e336d4bbcd4e)



### Users
Aqu√≠ almacenamos la informaci√≥n de los usuarios registrados en nuestra web. Puedes ver el nombre de usuario, correo electr√≥nico, contrase√±a, estado, fecha de creaci√≥n de la cuenta, √∫ltima conexi√≥n, amigos y los usuarios que ha bloqueado.

![image](https://github.com/user-attachments/assets/1700c6c9-b171-4909-bfc9-7e5d47ac572e)

![image](https://github.com/user-attachments/assets/3ab81af1-90b3-46a8-9389-d80e080309ae)



## Referencias que hemos consegido para crear la BBDD

Nuestro profesor Joaqu√≠n
Tutor√≠ales de Youtube:

* f
* f
* f
* f


<br>

<details>
  <summary>üîóüçÉ Como conectarte a la BBDD desde la Nube de MongoDB</summary>

Estos pasos son de priva para novatos para que se pueda entender mejor.

<br>

## Configuraci√≥n del Proyecto:

```
npm init -y
npm install express mongoose bcrypt cors
```
<br>


## Estructura de Archivos:

```
/proyecto
  /models
    User.js
  server.js
  /public
    index.html
    login.html
    dashboard.html
```


<br>

## Conexi√≥n con MongoDB (server.js):

```
const express = require('express');
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const cors = require('cors');
const app = express();

// Conexi√≥n a MongoDB Atlas
mongoose.connect('mongodb+srv://EGC:password1234@cluster0.kbtve.mongodb.net/EGC?retryWrites=true&w=majority', {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('Conectado a MongoDB Atlas'))
.catch(err => console.error(err));

app.use(express.json());
app.use(cors());
app.use(express.static('public'));

// Modelo User (models/User.js)
const userSchema = new mongoose.Schema({
  username: { type: String, unique: true },
  email: { type: String, unique: true },
  password_hash: String,
  status: String,
  created_at: Date,
  last_login: Date
});

const User = mongoose.model('User', userSchema);

// Rutas de autenticaci√≥n
app.post('/register', async (req, res) => {
  try {
    const hashedPassword = await bcrypt.hash(req.body.password, 10);
    const user = new User({
      username: req.body.username,
      email: req.body.email,
      password_hash: hashedPassword,
      status: 'offline',
      created_at: new Date()
    });
    await user.save();
    res.status(201).send('Usuario registrado');
  } catch (error) {
    res.status(500).send(error.message);
  }
});

app.post('/login', async (req, res) => {
  try {
    const user = await User.findOne({ username: req.body.username });
    if (!user) return res.status(400).send('Usuario no encontrado');
    
    const validPass = await bcrypt.compare(req.body.password, user.password_hash);
    if (!validPass) return res.status(400).send('Contrase√±a incorrecta');
    
    user.last_login = new Date();
    await user.save();
    res.send('Login exitoso');
  } catch (error) {
    res.status(500).send(error.message);
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Servidor en puerto ${PORT}`));
```


<br>

## Frontend (public/index.html - Registro):

```
<!DOCTYPE html>
<html>
<head>
    <title>Registro</title>
</head>
<body>
    <h2>Registro</h2>
    <form id="registerForm">
        <input type="text" id="username" placeholder="Usuario" required>
        <input type="email" id="email" placeholder="Email" required>
        <input type="password" id="password" placeholder="Contrase√±a" required>
        <button type="submit">Registrar</button>
    </form>

    <script>
        document.getElementById('registerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const response = await fetch('/register', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    username: document.getElementById('username').value,
                    email: document.getElementById('email').value,
                    password: document.getElementById('password').value
                })
            });
            
            const result = await response.text();
            alert(result);
        });
    </script>
</body>
</html>
```



<br>

## Frontend (public/login.html - Login):

```
<!DOCTYPE html>
<html>
<head>
    <title>Login</title>
</head>
<body>
    <h2>Login</h2>
    <form id="loginForm">
        <input type="text" id="username" placeholder="Usuario" required>
        <input type="password" id="password" placeholder="Contrase√±a" required>
        <button type="submit">Ingresar</button>
    </form>

    <script>
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const response = await fetch('/login', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    username: document.getElementById('username').value,
                    password: document.getElementById('password').value
                })
            });
            
            const result = await response.text();
            alert(result);
            if(response.ok) window.location.href = '/dashboard.html';
        });
    </script>
</body>
</html>
```



<br>

## Pasos para Ejecutar (Windows/Linux):


<br>

### Configura variables de entorno:

```
export MONGODB_URI='mongodb+srv://EGC:password1234@cluster0.kbtve.mongodb.net/EGC?retryWrites=true&w=majority'
```



<br>

### Inicia el servidor:

```
node server.js
```


<br>

### Accede desde tu navegador:

```
http://localhost:3000/index.html
http://localhost:3000/login.html
```



<br>

### Consideraciones de Seguridad:

1. Usa variables de entorno para credenciales (dotenv)

2. Implementa JWT para autenticaci√≥n

3. Agrega validaci√≥n de entrada

4. Usa HTTPS en producci√≥n

5. Limita intentos de login



<br>

### Para MongoDB Atlas:


1. Verifica la whitelist de IPs en Atlas

2. Mant√©n actualizados los drivers

3. Usa √≠ndices para consultas frecuentes

4. Implementa copias de seguridad regulares




  
</details>
<br>
<br>
<br>

  
</details>




<br>

<details>
  <summary>üåêüîóüí¨ WebSocket</summary>

# WebSocket

<br>

## ¬øQu√© es WebSocket?

WebSocket es un protocolo de comunicaci√≥n que proporciona un canal de comunicaci√≥n bidireccional y persistente entre el cliente (por ejemplo, un navegador web) y un servidor. A diferencia de los m√©todos tradicionales de comunicaci√≥n HTTP, donde cada solicitud del cliente al servidor crea una nueva conexi√≥n y debe cerrarse despu√©s de recibir la respuesta, WebSocket mantiene una conexi√≥n abierta, lo que permite que los datos se intercambien de manera continua sin necesidad de abrir nuevas conexiones.

![image](https://github.com/user-attachments/assets/02d4268b-ba83-4c6c-b205-21311c6c01ff)

<br>


## Caracter√≠sticas clave de WebSocket

1Ô∏è‚É£ Conexi√≥n persistente:

* ¬øQu√© significa? Una vez que se establece una conexi√≥n WebSocket entre el cliente y el servidor, esta se mantiene abierta durante todo el tiempo que sea necesario. No es como HTTP, que abre y cierra una conexi√≥n para cada solicitud. Esto mejora la eficiencia, ya que no es necesario realizar m√∫ltiples "handshakes" (intercambios de informaci√≥n para abrir y cerrar conexiones) constantemente.

* Beneficio: Permite que el servidor y el cliente se comuniquen continuamente sin la necesidad de establecer nuevas conexiones cada vez que haya algo que transmitir.


2Ô∏è‚É£ Comunicaci√≥n bidireccional:

* ¬øQu√© significa? Ambos lados de la conexi√≥n (el cliente y el servidor) pueden enviar y recibir datos en cualquier momento. Mientras que en HTTP el cliente generalmente hace solicitudes y espera respuestas del servidor, en WebSocket, tanto el servidor como el cliente pueden enviar mensajes sin que uno tenga que esperar al otro.

* Beneficio: Esto es especialmente √∫til para aplicaciones que requieren una comunicaci√≥n constante y sin interrupciones, como en chats o juegos en l√≠nea.


3Ô∏è‚É£ Baja latencia:

* ¬øQu√© significa? Dado que WebSocket mantiene una conexi√≥n abierta de manera persistente, los mensajes se pueden enviar y recibir sin la sobrecarga de establecer nuevas conexiones o esperar por respuestas del servidor. Esto reduce la latencia (el tiempo de espera entre enviar un mensaje y recibir una respuesta).

* Beneficio: Es ideal para aplicaciones en tiempo real donde los usuarios necesitan respuestas instant√°neas, como en aplicaciones de mensajer√≠a o en plataformas de trading financiero.


4Ô∏è‚É£ Protocolo basado en TCP:

* ¬øQu√© significa? WebSocket se construye sobre el protocolo de transmisi√≥n TCP (Transmission Control Protocol), que es un protocolo confiable. Esto significa que los datos se transmiten de manera ordenada y garantizada. Si alg√∫n paquete de datos se pierde, TCP se encarga de reintentarlo hasta que se reciba correctamente.

* Beneficio: Da confiabilidad a las comunicaciones, asegurando que los mensajes lleguen de manera correcta y en el orden adecuado.

<br>

## Casos de uso comunes

1Ô∏è‚É£ Aplicaciones en tiempo real:

* Ejemplos: Chats en vivo, mensajer√≠a instant√°nea, aplicaciones colaborativas.

* ¬øPor qu√© WebSocket? En estas aplicaciones, los usuarios esperan que los mensajes se reciban y se env√≠en de inmediato. Si se tuviera que abrir y cerrar una nueva conexi√≥n para cada mensaje, esto ser√≠a muy ineficiente. Con WebSocket, la conexi√≥n est√° siempre activa, permitiendo la transmisi√≥n instant√°nea de mensajes.


2Ô∏è‚É£ Juegos en l√≠nea:

* Ejemplos: Juegos multijugador, plataformas de juegos en tiempo real.

* ¬øPor qu√© WebSocket? Los juegos multijugador en l√≠nea requieren que el servidor y los jugadores se comuniquen constantemente para actualizar el estado del juego en tiempo real. Con WebSocket, los eventos del juego (como el movimiento de los personajes, la puntuaci√≥n, etc.) pueden ser enviados y recibidos de manera instant√°nea y continua sin la latencia de las solicitudes HTTP tradicionales.


3Ô∏è‚É£ Notificaciones en tiempo real:

* Ejemplos: Notificaciones de nuevos mensajes, alertas en aplicaciones, actualizaciones de noticias.

* ¬øPor qu√© WebSocket? Las notificaciones que se actualizan constantemente, como los avisos en una red social o las alertas de sistemas, requieren un intercambio de datos en tiempo real. WebSocket permite que el servidor "emita" las notificaciones directamente a los clientes conectados, sin que el cliente tenga que hacer una solicitud constante al servidor.


4Ô∏è‚É£ Plataformas de trading en l√≠nea:

* Ejemplos: Mercados de acciones, criptomonedas.

* ¬øPor qu√© WebSocket? En plataformas de trading, los precios de las acciones o las criptomonedas cambian r√°pidamente. Los traders necesitan informaci√≥n actualizada al instante para tomar decisiones informadas. WebSocket permite recibir actualizaciones de precios en tiempo real sin retrasos, lo que es crucial para una toma de decisiones √°gil.


5Ô∏è‚É£ Aplicaciones de colaboraci√≥n en tiempo real:

* Ejemplos: Google Docs, aplicaciones de edici√≥n compartida.

* ¬øPor qu√© WebSocket? Cuando varios usuarios est√°n colaborando en un mismo documento, los cambios deben ser reflejados en tiempo real para todos los participantes. WebSocket garantiza que los cambios de un usuario se env√≠en y reciban instant√°neamente, manteniendo todos los participantes sincronizados.

<br>
<br>
<br>

<details>
  <summary>+----------üå±üí¨ Lo basico</summary>

Para crear un **WebSocket** en un servidor Ubuntu Linux, generalmente se utiliza una tecnolog√≠a de servidor como Node.js, Python (con ```websockets``` o ```socket.io```), o incluso directamente en el servidor web (Apache, Nginx) con soporte para WebSocket. Aqu√≠ te voy a explicar c√≥mo crear un servidor WebSocket utilizando Node.js y el paquete ```ws```, que es uno de los m√©todos m√°s sencillos.

## Requisitos Previos

### 1. Tener un servidor Ubuntu Linux funcionando.

### 2. Tener Node.js instalado. Si no lo tienes, puedes instalarlo ejecutando los siguientes comandos:

```
sudo apt update
sudo apt upgrade
sudo apt install nodejs
sudo apt install npm
```

Para verificar que se instal√≥ correctamente:

```
node -v
npm -v
```

<br>

## Pasos para Crear un WebSocket con Node.js

### 1. Crea un directorio para tu proyecto.

```
mkdir websocket-server
cd websocket-server
```

### 2. Inicializa un nuevo proyecto Node.js.

```
npm init -y
```

Este comando generar√° un archivo ```package.json``` con la configuraci√≥n b√°sica de tu proyecto.


### 3. Instala el paquete ```ws```.

```ws``` es una librer√≠a simple y eficiente para trabajar con WebSockets en Node.js.

```
npm install ws
```

### 4. Crea un archivo de servidor WebSocket (por ejemplo, ```server.js```).

Crea el archivo ```server.js``` dentro de tu directorio de proyecto.

```
touch server.js
```

### 5. Escribe el c√≥digo para tu servidor WebSocket en server.js.

Abre server.js con tu editor de texto preferido (por ejemplo, nano, vim, o tu editor favorito). Escribe el siguiente c√≥digo:

```
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

// Mantener una lista de todos los clientes conectados
let clients = [];

wss.on('connection', (ws) => {
  console.log('Nuevo cliente conectado.');
  
  // Agregar el cliente a la lista
  clients.push(ws);

  // Enviar un mensaje de bienvenida al cliente
  ws.send('Bienvenido al servidor WebSocket. Ahora puedes chatear con otros usuarios.');

  // Escuchar mensajes enviados desde el cliente
  ws.on('message', (message) => {
    console.log(`Mensaje recibido: ${message}`);

    // Enviar el mensaje a todos los dem√°s clientes
    clients.forEach((client) => {
      if (client !== ws) {
        client.send(message);
      }
    });
  });

  // Manejar cierre de conexi√≥n
  ws.on('close', () => {
    console.log('Cliente desconectado');

    // Eliminar el cliente de la lista
    clients = clients.filter(client => client !== ws);
  });
});

console.log('Servidor WebSocket escuchando en ws://localhost:8080');
```

#### Explicaci√≥n:

* Lista de clientes: Creamos un array ```clients``` que almacenar√° todas las conexiones activas.
* Conexi√≥n y desconexi√≥n de clientes: Cuando un cliente se conecta, se agrega a esta lista. Cuando se desconecta, se elimina de la lista.
* Env√≠o de mensajes: Cuando un cliente env√≠a un mensaje, el servidor lo reenv√≠a a todos los dem√°s clientes en la lista (excepto al propio cliente que lo envi√≥).


### 6. Ejecuta el servidor WebSocket.

Una vez que hayas escrito el c√≥digo, guarda el archivo y ejecuta el servidor:

```
node server.js
```

El servidor ahora deber√≠a estar corriendo en ```ws://localhost:8080```.


### 7. Verifica que el servidor WebSocket est√° funcionando.

Abre un navegador web o usa una herramienta como Postman o un cliente WebSocket en JavaScript para conectarte al servidor. Si usas JavaScript en el navegador, puedes crear un cliente WebSocket simple de la siguiente manera:

En un archivo ```client.html```:

```
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cliente WebSocket</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }
    #messages {
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 20px;
      height: 200px;
      overflow-y: auto;
    }
    #inputMessage {
      width: 80%;
      padding: 10px;
    }
    #sendMessageButton {
      padding: 10px;
    }
  </style>
</head>
<body>
  <h1>Cliente WebSocket</h1>

  <div id="messages"></div>

  <input type="text" id="inputMessage" placeholder="Escribe tu mensaje...">
  <button id="sendMessageButton">Enviar mensaje</button>

  <script>
    // Conexi√≥n al servidor WebSocket
    const socket = new WebSocket('ws://localhost:8080');

    // Elementos de la p√°gina
    const messagesDiv = document.getElementById('messages');
    const inputMessage = document.getElementById('inputMessage');
    const sendMessageButton = document.getElementById('sendMessageButton');

    // Cuando se abre la conexi√≥n
    socket.onopen = function() {
      console.log('Conectado al servidor WebSocket');
    };

    // Cuando se recibe un mensaje del servidor
    socket.onmessage = function(event) {
      const message = event.data; // Esto es el mensaje recibido

      // Si el mensaje es un Blob (lo que indica que es binario), convertirlo a texto
      if (message instanceof Blob) {
        message.text().then(function(text) {
          console.log('Mensaje recibido del servidor: ' + text);

          // Mostrar el mensaje recibido en el div de mensajes
          const messageDiv = document.createElement('div');
          messageDiv.textContent = 'Otro usuario: ' + text;
          messagesDiv.appendChild(messageDiv);
          messagesDiv.scrollTop = messagesDiv.scrollHeight;
        });
      } else {
        // Si el mensaje ya es texto, simplemente mostrarlo
        console.log('Mensaje recibido del servidor: ' + message);

        // Mostrar el mensaje recibido en el div de mensajes
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'Otro usuario: ' + message;
        messagesDiv.appendChild(messageDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      }
    };

    // Cuando se cierra la conexi√≥n
    socket.onclose = function() {
      console.log('Desconectado del servidor WebSocket');
    };

    // Enviar mensaje al servidor cuando el usuario hace clic en el bot√≥n
    sendMessageButton.addEventListener('click', function() {
      const messageToSend = inputMessage.value;
      if (messageToSend) {
        // Enviar el mensaje al servidor WebSocket
        socket.send(messageToSend);

        // Mostrar el mensaje en la p√°gina como si fuera del cliente
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'T√∫: ' + messageToSend;
        messagesDiv.appendChild(messageDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;

        // Limpiar el campo de entrada
        inputMessage.value = '';
      }
    });

    // Opcional: Enviar el mensaje cuando presionas Enter
    inputMessage.addEventListener('keypress', function(event) {
      if (event.key === 'Enter') {
        sendMessageButton.click();
      }
    });
  </script>
</body>
</html>

```

#### Explicaci√≥n:

##### Detecci√≥n de tipo Blob:

* Al recibir un mensaje del servidor en el cliente, primero se verifica si el mensaje es de tipo Blob. Esto se hace con if (message instanceof Blob).

* Si el mensaje es un Blob, usamos el m√©todo .text() para convertirlo a texto antes de mostrarlo. El .text() devuelve una promesa que resuelve en el contenido del Blob como una cadena de texto.

* Si el mensaje no es un Blob, se considera que ya es texto y se muestra directamente.

##### Manejo de mensajes:

* Cuando el mensaje recibido es texto, se muestra como antes: en el div con id messages.

* Si el mensaje es un Blob, primero lo convertimos a texto y luego lo mostramos en el div.








</details>


<br>
<br>
<br>


<details>
  <summary>+----------üß†üåêüöÄ Avanzado</summary>
en progreo



</details>









</details>

<br>

<details>
  <summary>üñ•Ô∏èüåêüíª Servidor Web</summary>

# ¬øQu√© es un Servidor de Web?

Un servidor web es un software o sistema que se encarga de recibir, procesar y responder a las solicitudes que los navegadores web (o cualquier cliente HTTP) env√≠an para acceder a los recursos alojados en un sitio web. Los recursos m√°s comunes que maneja un servidor web son las p√°ginas web, que generalmente est√°n escritas en HTML, pero tambi√©n puede servir otros tipos de contenido como im√°genes, videos, archivos CSS, JavaScript y m√°s.

Cuando un usuario ingresa una direcci√≥n web (URL) en su navegador, el navegador env√≠a una solicitud HTTP al servidor web correspondiente. El servidor web luego procesa esa solicitud, recupera el archivo solicitado (por ejemplo, una p√°gina HTML) y lo env√≠a de vuelta al navegador para que se muestre al usuario.

![image](https://github.com/user-attachments/assets/1e220d5f-dd4c-4ba5-969a-c6fc51c6eb69)

<br>

Los pasos b√°sicos de funcionamiento de un servidor web son:

* Recepci√≥n de la solicitud: El navegador realiza una solicitud HTTP al servidor web, generalmente solicitando un archivo o recurso espec√≠fico.

* Procesamiento de la solicitud: El servidor verifica la solicitud y, si es v√°lida, busca el recurso solicitado (por ejemplo, una p√°gina HTML).

* Env√≠o de la respuesta: Una vez que el recurso ha sido encontrado, el servidor web env√≠a el archivo al navegador del usuario, que lo muestra en la pantalla.

Algunos ejemplos populares de servidores web son:

* Apache HTTP Server: Muy popular y ampliamente utilizado en entornos Linux.

* Nginx: Conocido por su alto rendimiento y eficiencia.

* Microsoft IIS: Utilizado principalmente en entornos Windows.

<br>
<br>
<br>

# ¬øQu√© es un NGINX?

NGINX es un servidor web de alto rendimiento, servidor proxy inverso y balanceador de carga muy utilizado en la infraestructura de Internet. Fue creado originalmente para ser un servidor web, pero con el tiempo ha evolucionado para ofrecer m√∫ltiples funcionalidades adicionales. Su principal ventaja es su capacidad para manejar un gran volumen de conexiones concurrentes de manera eficiente y con un bajo uso de recursos.

![Comandos-de-Nginx-que-usted-debe-saber-removebg-preview](https://github.com/user-attachments/assets/72dd8064-c11a-4840-92f3-c7218227b21c)

<br>

Algunas de las funciones m√°s destacadas de NGINX incluyen:

* Servidor web: Sirve contenido est√°tico (como archivos HTML, im√°genes, videos) a los usuarios.

* Proxy inverso: Redirige las solicitudes de los usuarios a otros servidores (por ejemplo, servidores de aplicaciones), mejorando la seguridad y la carga de trabajo distribuida.

* Balanceador de carga: Distribuye el tr√°fico de red entre varios servidores para asegurar que ninguno de ellos se sobrecargue, mejorando la disponibilidad y la fiabilidad del sistema.

* Cacheo: Guarda en memoria las respuestas de servidores backend para reducir la carga y acelerar las respuestas a los usuarios.

  NGINX es conocido por su alta eficiencia y su capacidad para manejar miles de conexiones simult√°neas con un uso m√≠nimo de recursos, lo que lo convierte en una opci√≥n popular para aplicaciones web de alto tr√°fico.

  Es muy com√∫n encontrarlo en la infraestructura de empresas que gestionan aplicaciones web de gran escala.

<br>
<br>
<br>

# Los pasos para crear el Servidor Web con NGINX

## Paso 1: Actualizar los paquetes del sistema
Antes de instalar NGINX, es recomendable actualizar la lista de paquetes disponibles y los paquetes del sistema para asegurarse de que estamos trabajando con versiones recientes.
```
sudo apt update
sudo apt upgrade -y

```

## Paso 2: Instalar NGINX

Una vez actualizado el sistema, se puede instalar NGINX utilizando el gestor de paquetes apt:

```
sudo apt install nginx -y
```

## Paso 3: Verificar la instalaci√≥n de NGINX
Una vez que la instalaci√≥n haya finalizado, puedes verificar que NGINX se haya instalado correctamente ejecutando:

```
nginx -v
```



</details>

<br>

<details>
  <summary>üñ•Ô∏èüåêüîÑ Servidor DNS</summary>

Un servidor DNS (Domain Name System) es un sistema que traduce los nombres de dominio (como www.ejemplo.com) en direcciones IP (como 192.168.1.1) que las computadoras usan para identificarse y comunicarse en una red, como Internet.

![image](https://github.com/user-attachments/assets/f216feb9-9c30-4a78-bf23-e86f54922e99)

<br>

Cuando escribes una direcci√≥n web en tu navegador, el servidor DNS se encarga de buscar la direcci√≥n IP correspondiente a ese nombre de dominio para que puedas acceder al sitio web. Esto es necesario porque las computadoras y otros dispositivos en una red se identifican mediante direcciones IP, pero para los usuarios es mucho m√°s f√°cil recordar nombres de dominio que n√∫meros de IP.

En resumen, el servidor DNS act√∫a como una especie de "agenda telef√≥nica" de Internet, ayudando a resolver los nombres de dominio en las direcciones num√©ricas necesarias para acceder a los recursos en l√≠nea.



</details>


<br>

<details>
  <summary>‚úâÔ∏è Servidor Correo</summary>

# Servidor Correo

Un servidor de correo es una computadora o sistema que gestiona y distribuye los correos electr√≥nicos entre los usuarios. Su funci√≥n principal es recibir, almacenar y enviar mensajes de correo electr√≥nico. Los servidores de correo se encargan de facilitar la comunicaci√≥n a trav√©s del correo electr√≥nico en redes locales o en Internet.

![imagen_2025-03-17_170139970-removebg-preview](https://github.com/user-attachments/assets/a2bbb248-9043-45a1-9ec1-26706097fff0)

<br>

Existen diferentes tipos de servidores de correo, como:

## 1. Servidor de correo entrante (IMAP/POP3)
Se encarga de recibir y almacenar los correos en una bandeja de entrada. El usuario puede acceder a sus mensajes a trav√©s de un cliente de correo, como Outlook, Thunderbird, o aplicaciones m√≥viles. IMAP (Internet Message Access Protocol) mantiene los mensajes en el servidor, mientras que POP3 (Post Office Protocol) descarga los correos al dispositivo y los elimina del servidor.


## 2. Servidor de correo saliente (SMTP)
Es el responsable de enviar los correos electr√≥nicos a otros servidores o destinatarios. SMTP (Simple Mail Transfer Protocol) es el protocolo utilizado para enviar los mensajes.


## Cual es nuestro servidor de correo






</details>



<br>



<br><br><br>




# Tema sobre la WEB

<details>
  <summary>üáπüá© Chat</summary>
  
  # Chat Interface Concept
  
  https://codepen.io/emilcarlsson/pen/ZOQZaV
  
  ![image](https://github.com/user-attachments/assets/15b8bdd0-554e-4116-b73e-086db5766ed0)


  # 5 –ñ–∏–≤–æ–π —á–∞—Ç / Live chat
  
  https://codepen.io/retyui/pen/zxGqPJ
  
  ![image](https://github.com/user-attachments/assets/12b26776-440e-474e-89f1-c7695ad79702)


  # Sidebar AdminLTE
  
  https://codepen.io/jasp402/pen/VrYzNw
  
  ![image](https://github.com/user-attachments/assets/bec42ba2-6cfc-4304-b220-cf128d50d4c9)


  # Material Messaging App Concept
  
  https://codepen.io/ThomasDaubenton/pen/QMqaBN
  
  ![image](https://github.com/user-attachments/assets/9b322906-8ead-4d2a-ba92-3e964af13b26)


  # Discord Mockup
  
  https://codepen.io/odensc/pen/vxpMPp
  
  ![image](https://github.com/user-attachments/assets/3d085bc8-4ab1-4b66-8061-8894e0c203a2)


</details>
<br>



<details>
  <summary>üìß Enviar email a la empresa</summary>
  
  # Responsive Contact Form
  
  https://codepen.io/wgnr/pen/ExKzNJ

  ![image](https://github.com/user-attachments/assets/5a7ec21a-ad85-4233-a0f6-54e7b55af226)


  

  ##



</details>
<br>



<details>
  <summary>üìù|‚ñ∂Ô∏è Registrar | Inicio</summary>
  
  # Responsive Registration Form
  
  https://codepen.io/anandaprojapati/pen/GmrwYE

  ![image](https://github.com/user-attachments/assets/29bfc20d-0d2a-4ef1-bdfb-7d361b2c3ae3)


  #



</details>
<br>




<details>
  <summary>üé® Dise√±os graficos</summary>
  
  # üî≤ H Y P E R H E D R O N üî≤

  https://codepen.io/shshaw/pen/eGYZOe

  ![image](https://github.com/user-attachments/assets/1455a975-41b5-4e03-9d98-42e1d57146c8)



  # canvas base typeface

  https://codepen.io/ara_node/pen/DdNQqQ

  ![image](https://github.com/user-attachments/assets/5793e444-87d7-40be-80b9-172d0b93ea7d)


  # #Anonymous Hacker Portfolio

  https://codepen.io/Breekee/pen/QWjjdOQ
  
  ![image](https://github.com/user-attachments/assets/2443b86b-ee03-4f8a-92f5-4db8135efbd1)


  # Text Glitch

  https://codepen.io/alexr4/pen/BqVbLr

  ![image](https://github.com/user-attachments/assets/567ab563-e313-4e3b-9283-8133a3e4bfb2)


  #

</details>
<br>



